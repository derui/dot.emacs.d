#+STARTUP: content

* Initial configuration

** Initialize straight
#+begin_src emacs-lisp
  (eval-when-compile
    (require 'cl-lib))
  (add-to-list 'native-comp-eln-load-path (expand-file-name "eln-cache" user-emacs-directory))

  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 6))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

** Initialize leaf
#+begin_src emacs-lisp
  (straight-use-package 'leaf)
  (straight-use-package 'leaf-keywords)

  (require 'leaf)

  (leaf leaf-keywords
    :require t
    :config
    (leaf-keywords-init))
#+end_src

** 起動時間を計測する
#+begin_src emacs-lisp
  (defconst my:time-zero (current-time))
  (defvar my:time-list nil)

  (defun my:time-lag-calc (lag label)
    (if (assoc label my:time-list)
        (setcdr (assoc label my:time-list)
                (- lag (cdr (assoc label my:time-list))))
      (setq my:time-list (cons (cons label lag) my:time-list))))

  (defun my:time-lag (label)
    (let* ((now (current-time))
           (min (- (car now) (car my:time-zero)))
           (sec (- (car (cdr now)) (car (cdr my:time-zero))))
           (msec (/ (- (car (cdr (cdr now)))
                       (car (cdr (cdr my:time-zero))))
                    1000))
           (lag (+ (* 60000 min) (* 1000 sec) msec)))
      (my:time-lag-calc lag label)))

  (defun my:time-lag-print ()
    (message (prin1-to-string
              (sort my:time-list
                    (lambda  (x y)  (> (cdr x) (cdr y)))))))

  (my:time-lag "total")

  (add-hook 'after-init-hook #'(lambda () (my:time-lag "total") (my:time-lag-print)) t)
#+end_src

* ユーザーの環境定義
** カスタムの定義
基本的には、defcustomを使っていった方がいいということなので、defcustomを使う。

#+begin_src emacs-lisp
  (defgroup my nil "My custom group" :group 'configuration)
  (defcustom my:font-size 10.5
    "current font size"
    :group 'my
    :type 'number)
  (defcustom my:font-family "HackGen"
    "current font family"
    :group 'my
    :type 'string)
  (defcustom my:input-method 'japanese-mozc
    "input method"
    :group 'my
    :type 'symbol)
  (defcustom my:save-buffer-hook
    nil
    "ユーザーが独自に登録可能なsave-buffer-hookへのhook"
    :group 'my
    :type 'string)

  (defcustom my:ispell-regexp-ja "[一-龠ぁ-🈀ァ-𛀀ー・、。々]+"
    "Regular expression to match a Japanese word.
  The expression can be [^\000-\377]+, [^!-~]+, or [一-龠ぁ-🈀ァ-𛀀ー・、。々]+"
    :group 'my
    :type 'string)

  (defcustom my:trailing-whitespace-exclude-modes
    '(org-mode)
    "Do not trailing whitespace in these modes"
    :group 'my
    :type '(symbol))
  (defcustom my:user-local-exec-path
    "~/.local/bin"
    "The location user-local executable path"
    :group 'my
    :type 'string)
#+end_src

Langtoolに関する設定変数など。

#+begin_src emacs-lisp
  (defcustom my:langtool-version
    "4.2"
    "The version of Langtool"
    :group 'my
    :type 'string)

  (defcustom my:langtool-cli-path
    (expand-file-name (locate-user-emacs-file
                       (format "share/LanguageTool-%s/languagetool-commandline.jar"
                               my:langtool-version)))
    "The path of langtool CLI"
    :group 'my
    :type 'string)
#+end_src

SKKに関する変数。辞書サーバーを使いたい場合は、 ~my:use-skkserver~ を non-nilにしたらよい。

#+begin_src emacs-lisp

  (defvar skk-user-directory (expand-file-name "skk" user-emacs-directory))
  ;; SKK server(利用するのはyaskkserv2を利用する
  (defcustom my:use-skkserver t
    "Use skk server or not"
    :group 'my
    :type 'boolean)

  ;; SKK serverをbuildする(要cargo)
  (defcustom my:build-skkserver
    nil
    "Build skk server if not available in system"
    :group 'my
    :type 'boolean)

  ;; yaskkserv2のバージョン
  (defcustom my:yaskkserv2-version "0.1.1"
    "The version of yaskkserv2"
    :group 'my
    :type 'string)
#+end_src

posframeを使うかどうか。

#+begin_src emacs-lisp
  (defcustom my:use-posframe t
    "Use posframe entirely"
    :group 'my
    :type 'boolean)
#+end_src

*** org-roam
#+begin_src emacs-lisp
  (defcustom my:org-roam-db-location
    "~/.emacs.d/share/org-roam.db"
    "The location of database that is used by org-roam"
    :group 'my
    :type 'string)

  (defcustom my:org-roam-directory
    "~/Dropbox/git/roam"
    "The location of roam files"
    :group 'my
    :type 'directory)

  (defcustom my:org-roam-dailies-directory
    "~/Dropbox/git/roam-daily"
    "The location of roam-daily files"
    :group 'my
    :type 'directory)

  (defcustom my:org-roam-index-file
    (expand-file-name "index.org" my:org-roam-directory)
    "The location of index file"
    :group 'my
    :type 'file)
#+end_src

** 環境ごとの設定
環境によって異なる設定はここで定義しておく。これらは別ファイルで設定できるようにする。

#+begin_src emacs-lisp
  (defcustom my:mozc-el-locate nil
    "Location of mozc.el"
    :group 'my
    :type 'file)

  (defcustom my:mozc-helper-locate nil
    "Location of emacs-mozc-helper"
    :group 'my
    :type 'file)

  (defcustom my:virtualenv-path nil
    "Location of virtualenv's environment"
    :group 'my
    :type 'file)

  (defcustom my:roswell-path nil
    "Location of roswell"
    :group 'my
    :type 'file)

  (defcustom my:use-mozc-el nil
    "Use mozc as input method"
    :group 'my
    :type 'boolean)

  (defcustom my:migemo-command nil
    "The path of migemo-like executable"
    :group 'my
    :type 'file)

  (defcustom my:migemo-dictionary nil
    "The path of dictionaries for migemo"
    :group 'my
    :type 'directory)

  (defcustom my:cargo-path nil
    "The path of cargo executable"
    :group 'my
    :type 'file)

  (defcustom my:rust-analyzer-version nil
    "The path of rust-analyzer executable"
    :group 'my
    :type 'file)
#+end_src

** 外部設定の読込み
git管理外になっているファイル。これは、パス関連など、環境毎に違うので登録するとめんどくさいものに対して利用する。

#+begin_src emacs-lisp
  (let ((user-env (locate-user-emacs-file "conf/user-env.el")))
    (load user-env t))
#+end_src

** 実行パスの設定
exec-pathに必要なパスを追加する。

#+begin_src emacs-lisp
  (add-to-list 'exec-path (expand-file-name "~/.npm/bin"))
  (add-to-list 'exec-path (expand-file-name "~/.asdf/shims"))
  (add-to-list 'exec-path "/usr/local/bin")
  (add-to-list 'exec-path "/usr/bin")
  (add-to-list 'exec-path "/usr/sbin")
  (add-to-list 'exec-path my:user-local-exec-path)
  (add-to-list 'exec-path (expand-file-name "bin" my:roswell-path))
  (add-to-list 'exec-path (expand-file-name "bin" my:cargo-path))
#+end_src

** init.elの内容
#+begin_src emacs-lisp
  (defvar my:init.el-content
    '(progn
       (require 'org)
       ;; Do always overwrite init.el from generated source from init.org
       (org-babel-tangle-file (expand-file-name "init.org" user-emacs-directory)
                              (expand-file-name "init.el" user-emacs-directory))
       (load (expand-file-name "init.el" user-emacs-directory))
       (message "Once kill emacs for apply new init.el written from init.org")
       (setq kill-emacs-hook nil)
       (kill-emacs nil t))

    "init.el contents")
#+end_src

* Emacs base configuration
** 基本設定
*** languages
right-to-leftを無効化して、多少でもパフォーマンスを上げる。
#+begin_src emacs-lisp
  (setq-default bidi-display-reordering nil)
#+end_src

言語環境は日本語。かつ、キーボードから入力される文字コードはutf-8。
#+begin_src emacs-lisp
  (set-language-environment 'Japanese)
  (set-keyboard-coding-system 'utf-8)
#+end_src

文字コードの推測ではutf-8を優先する。
#+begin_src emacs-lisp
  (setq buffer-file-coding-system 'utf-8-unix)
  (prefer-coding-system 'utf-8-unix)
#+end_src

*** enable functions
各種のデフォルトでは無効化されている関数を有効化する。
#+begin_src emacs-lisp
  (put 'narrow-to-defun 'disabled nil)
  (put 'narrow-to-page 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'set-goal-column 'disabled nil)
#+end_src

backspaceまたはdeleteキーで削除が行えるようにする。
#+begin_src emacs-lisp
  (if (fboundp 'normal-erase-is-backspace-mode)
      (normal-erase-is-backspace-mode 0))
#+end_src

*** change default behaviors
**** スタートページを表示しない
#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
#+end_src

**** yes/noではなくy/nで回答できるようにする
#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

**** バックアップファイルは作らない
#+begin_src emacs-lisp
  (setq backup-inhibited t)
#+end_src

**** 自動保存ファイルは作らない
#+begin_src emacs-lisp
  (setq auto-save-default nil)
#+end_src

**** タブ入力時のインデント設定
#+begin_src emacs-lisp
  (setq indent-line-function #'indent-relative-first-indent-point)
  (setq-default tab-width 4)
  (setq-default indent-tabs-mode nil)
  (setq-default tab-always-indent 'complete)
#+end_src

**** コメントのスタイル設定
#+begin_src emacs-lisp
  (setq comment-style 'indent)
#+end_src

**** 画面端での折り返しを有効にする
#+begin_src emacs-lisp
  (setq truncate-lines t)
#+end_src

**** auto-fill時にインデントを考慮する
#+begin_src emacs-lisp
  (setq adaptive-fill-regexp "[ \t]*")
#+end_src

**** lockファイルは作成しない
#+begin_src emacs-lisp
  (setq create-lockfiles nil)
#+end_src

**** bufferのrevertをすぐに行うようにする
#+begin_src emacs-lisp
  (setq auto-revert-interval 1)
#+end_src

**** processから読み出せる量を増やす
#+begin_src emacs-lisp
  (setq read-process-output-max (* 1024 1024))
#+end_src

**** capfの挙動を変更する
capfでは大文字小文字を区別しない。
#+begin_src emacs-lisp
  (setq completion-ignore-case t)
  (setq completion-styles `(basic
                            ,(if (version<= emacs-version "27.0") 'helm-flex 'flex)))
#+end_src

**** ring bellは鳴らさない
#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
#+end_src

**** cursorは点滅させない
#+begin_src emacs-lisp
  (blink-cursor-mode 0)
#+end_src

**** 常に最終行を追加する
#+begin_src emacs-lisp
  (setq require-final-newline t)
#+end_src

**** VCでのsymlink確認をしないようにする
#+begin_src emacs-lisp
  (setq vc-follow-symlinks t)
#+end_src

**** ダイアログボックスを利用しない
#+begin_src emacs-lisp
  (setq use-dialog-box nil)
#+end_src

*** macOS限定の設定
#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    ;; altとMetaを入れ替える
    (setq mac-option-modifier 'alt)
    (setq mac-command-modifier 'meta))
#+end_src

*** font-lock
#+begin_src emacs-lisp
  (setq font-lock-support-mode 'jit-lock-mode)
#+end_src

**** 全角空白やタブに色をつける
#+begin_src emacs-lisp
  (defface my-face-b-2 '((t (:background "gray26"))) "face for tab" :group 'my)
  (defface my-face-u-1 '((t (:foreground "SteelBlue" :underline t))) "" :group 'my)
  (defvar my-face-b-2 'my-face-b-2)
  (defvar my-face-u-1 'my-face-u-1)

  (defun my:font-lock-mode (&rest args)
    (font-lock-add-keywords
     major-mode
     '(("\t" 0 my-face-b-2 append)
       ("[ \t]+$" 0 my-face-u-1 append))))
  (advice-add 'font-lock-mode :before 'my:font-lock-mode)
#+end_src

**** bookmarkのfaceを無効化する
Emacs 28.1からデフォルト値が変更されたので、元々のfaceに合うように戻す。

#+begin_src emacs-lisp
  (leaf *face
    :after (bookmark modus-themes)
    :if (version<= "28" emacs-version)
    :config
    (set-face-attribute 'bookmark-face nil :foreground nil :background nil :inherit nil))
#+end_src

**** mode lineでvariable pitchを使わないようにする
Emacs 29でなんでかmode lineのフォントとしてvariable pitchが利用されるような設定が追加されたので、同じものを利用するようにする。

#+begin_src emacs-lisp
  (leaf *mode-line-face
    :if (version<= "29" emacs-version)
    :config
    ;; mode lineをvariable pitchではなく等幅フォントを利用する。
    (set-face-attribute 'mode-line-active nil :inherit 'mode-line))

#+end_src

*** 行番号を表示する
#+begin_src emacs-lisp
  (leaf *line-number
    :if (and nil version<= "27.0.0" emacs-version)
    :custom
    (display-line-numbers-width-start . t)
    ;; show relative line number as visual line
    (display-line-numbers-type . t)
    :config
    (global-display-line-numbers-mode t))
#+end_src

*** グローバルに有効にするmode
#+begin_src emacs-lisp
  (global-font-lock-mode +1)

  (leaf *show-paren-mode
    :config
    (show-paren-mode t))

  (transient-mark-mode 1)

  ;; pixelベースのスクロール処理
  (pixel-scroll-precision-mode)
#+end_src

*** GUI設定
GUIで起動しても、スクロールバーやメニューはいらないので表示しない。
行番号についても、ネイティブの表示があるので表示しない。

#+begin_src emacs-lisp
  (scroll-bar-mode -1)
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (line-number-mode 0)
  (column-number-mode 0)
  (leaf *mini-frame
    :if (version<= "27" emacs-version)
    :config
    (setq resize-mini-frames t))
#+end_src

*** GCの設定
~#x10000000~ = ~256MiB~ を閾値としておく。これはLSPの対策のため。

#+begin_src emacs-lisp
  (setq gc-cons-threshold #x10000000)
  (setq gc-cons-percentage 0.5)
  (setq garbage-collection-messages t)
#+end_src

*** major-modeのhookをdirectory localの後に起動できるようにする
https://blog.tomoya.dev/posts/how-to-automatically-switch-lsp-servers-in-lsp-mode/

denoとts-lsを切り替えながらやりたい場合などに利用する。directory localを適用してからhookを実行したい場合は、  ~<major-mode>-local-vars-hook~ というhookを実行すること。

#+begin_src emacs-lisp
  (defun my:run-local-vars-mode-hook ()
    "Run `major-mode' hook after the local variables have been processed."
    (run-hooks (intern (concat (symbol-name major-mode) "-local-vars-hook"))))
  (add-hook 'hack-local-variables-hook 'my:run-local-vars-mode-hook)
#+end_src

*** themeの設定
theme全体に関わる設定。

#+begin_src emacs-lisp
  ;; 主にmodus themeにおいて、lisp codeの実行を許容するための設定
  (setq custom-safe-themes t)
#+end_src

*** focus outしたら強制保存
#+begin_src emacs-lisp
  (defun my:save-all-buffers ()
    (save-some-buffers "!"))

  (add-hook 'focus-out-hook #'my:save-all-buffers)
#+end_src
** 標準パッケージ
*** browse-url
#+begin_src emacs-lisp
  (leaf browse-url
    :require t
    :config
    (cond
     ((executable-find "firefox-bin")
      (progn
        (setq browse-url-browser-function #'browse-url-firefox)
        (setq browse-url-generic-program "firefox-bin")
        (setq browse-url-firefox-program "firefox-bin")))
     ((executable-find "chromium")
      (progn
        (setq browse-url-browser-function #'browse-url-chromium)
        (setq browse-url-generic-program "chromium")))
     ((executable-find "vivaldi")
      (progn
        (setq browse-url-browser-function #'browse-url-chromium)
        (setq browse-url-generic-program "vivaldi")))))
#+end_src
*** server
#+begin_src emacs-lisp
  (leaf server
    :require t
    :hook
    (server-switch-hook . temporary-edit-mode)
    :config
    (unless (server-running-p)
      (server-start))

    ;; define server-editing specialized minor mode
    (defun my:copy-input-and-exit ()
      "Copy the current input to the kill ring and exit."
      (interactive)
      (let ((buffer (current-buffer))
            (select-enable-clipboard t))

        (my:copy-with-system-clipboard (buffer-substring-no-properties (point-min) (point-max)))

        (or (delete-frame)
            (server-edit))

        (with-current-buffer buffer
          (let (kill-buffer-hook kill-buffer-query-functions)
            (set-buffer-modified-p 'nil)
            (kill-buffer)))))
    
    (define-minor-mode temporary-edit-mode
      "Temporary editing mode with server"
      :keymap (let ((map (make-sparse-keymap)))
                (define-key map (kbd "C-c C-c") 'my:copy-input-and-exit)
                map)))
#+end_src
*** dired
#+begin_src emacs-lisp
  (leaf dired
    :require t
    :preface
    (defun my:dired-convert-coding-system ()
      "現在diredで選択されているファイルに対して、文字コードを変換する。"
      (let ((file (dired-get-filename))
            (coding-system-for-write my:dired-file-coding-system)
            failure)
        (condition-case err
            (with-temp-buffer
              (insert-file-contents file)
              (write-region (point-min) (point-max) file))
          (error (setq failure err)))
        (if (not failure)
            nil
          (dired-log "convert coding system error for %s:\n%s\n" file failure)
          (dired-make-relative file))))

    (defun my:dired-next-buffer-on-window ()
      "現在のdiredバッファ以外で、かつ他のwindowに存在しているdired bufferに移動する。
  対象になるバッファが無い場合は何もしない"
      (interactive)
      (when-let ((next-dired-buffer (seq-find
                                     (lambda (buf)
                                       (and (eq 'dired-mode (buffer-local-value 'major-mode buf))
                                            (not (eq (current-buffer) buf))
                                            (get-buffer-window buf)))
                                     (buffer-list))))
        (select-window (get-buffer-window next-dired-buffer))))
    :bind
    (:dired-mode-map
     ("T" . my:dired-do-convert-coding-system)
     ;; dired内でもhjklで移動できるようにしておく
     ("h" . dired-up-directory)
     ("l" . dired-find-file)
     ("j" . dired-next-line)
     ("k" . dired-previous-line)
     ;; 2画面ファイラっぽく、次に開いているdiredバッファに移動できるようにする
     ("<tab>" . my:dired-next-buffer-on-window)
     )
    :custom
    ;; diredでファイルをコピーする際に、コピー先をもう一つのdiredに切り替える
    (dired-dwim-target . t)
    (dired-recursive-copies . 'always)
    (dired-recursive-deletes . 'always)
    (dired-listing-switches . "-al --group-directories-first")
    ;; 標準で用意された、新規にdiredを開かないようにするための処理
    (dired-kill-when-opening-new-dired-buffer . t)
    :config
    ;; macOSの場合、lsがcoreutilsとは別物なので、coreutils版の方を利用するように切り替える
    (when (eq system-type 'darwin)
      (setq insert-directory-program "gls")))
#+end_src
**** wdired
#+begin_src emacs-lisp
  (leaf wdired :require t
    :bind
    (:dired-mode-map
     ("E" . wdired-change-to-wdired-mode)))
#+end_src
*** uniquify
バッファ名を単一化するためのpackage。
    
#+begin_src emacs-lisp
  (leaf uniquify
    :require t
    :custom
    (uniquify-buffer-name-style . 'forward)
    (uniquify-separator . "/")
    (uniquify-after-kill-buffer-p . t)    ; rename after killing uniquified
    (uniquify-ignore-buffers-re . "^\\*") ; don't muck with special buffers
    )
#+end_src
*** shell
#+begin_src emacs-lisp
  (leaf shell
    :require t
    :custom
    (explicit-shell-file-name . "/bin/bash")
    (shell-file-name . "/bin/bash")
    :config
    (setq shell-command-switch "-c")
    (setenv "EMACS" "t"))
#+end_src
*** flyspell
flyspellは、そのままだと日本語が混ざっていてもエラーにしてしまうので、日本語が混ざっている場合は無視するようにする。

#+begin_src emacs-lisp
  (leaf ispell
    :require t
    :if (executable-find "hunspell")
    :custom
    (flyspell-default-dictionary . "en_US")
    (ispell-dictionary . "en_US")
    (ispell-local-dictionary-alist .
                                   '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)))
    (ispell-hunspell-dictionary-alist . ispell-local-dictionary-alist)

    ;; for performance
    (flyspell-issue-message-flag . nil)
    :config
    (setq ispell-program-name (executable-find "hunspell")))

  (leaf flyspell
    :require t
    :hook
    (flyspell-incorrect-hook . my:flyspell-skip-ja)
    :config
    (defun my:flyspell-skip-ja (beg end info)
      "Tell flyspell to skip a Japanese word.
  Call this on `flyspell-incorrect-hook'."
      (string-match my:ispell-regexp-ja (buffer-substring beg end)))

    (defun my:flyspell-enable ()
      "The function to enable flyspell in current buffer."
      (interactive)
      (flyspell-mode 1)))
#+end_src

*** recentf
#+begin_src emacs-lisp
  (leaf recentf
    :require t
    :custom
    ;; 最大1000まで保存するようにする
    (recentf-max-saved-items . 1000)
    :config
    ;; /tmpのものはそもそも残らないようにする
    (add-to-list 'recentf-exclude "/tmp/*")
    (recentf-mode +1))
#+end_src
*** dabbrev
#+begin_src emacs-lisp
  (leaf dabbrev
    :ensure t
    :bind (("M-/" . dabbrev-completion)
           ("C-M-/" . dabbrev-expand)))
#+end_src
*** project.el
プロジェクト管理用の各種基本的な処理を提供してくれる。

#+begin_src emacs-lisp
  (leaf project
    :ensure t
    :config
    (defun my:project-try-nodejs (dir)
      "Find a super-directory of DIR containing a package.json file."
      (let ((dir (locate-dominating-file dir "package.json")))
        (and dir (cons 'explicit dir))))

    (cl-defmethod project-root ((project (head explicit)))
      (cdr project))

    (add-hook 'project-find-functions #'my:project-try-nodejs))
#+end_src
*** files
#+begin_src emacs-lisp
  (leaf files
    :require t
    :custom
    ;; ３０秒操作がなかったら自動保存
    (auto-save-interval . 30)
    :config
    (auto-save-visited-mode 1))
#+end_src
*** hl-line
    現在行の表示を行う組み込みのpackage。

    #+begin_src emacs-lisp
      (leaf hl-line
        :ensure t
        :config
        (global-hl-line-mode 1))
    #+end_src
*** electric-pair
    標準であるpairの挿入package。

    #+begin_src emacs-lisp
      (leaf elec-pair
        :require t
        :hook
        (prog-mode-hook . electric-pair-mode))
    #+end_src
** global-set-keyの設定
#+begin_src emacs-lisp
  (leaf *key-binding
    :config
    (leaf *global
      :config
      (global-set-key (kbd "C-z") nil)
      (global-set-key (kbd "C-h") #'backward-delete-char)
      (global-set-key (kbd "M-?") #'help-for-help)
      (global-set-key (kbd "M-d") #'my:kill-word-at-point)
      (global-set-key (kbd "C-m") #'newline-and-indent)
      (global-set-key (kbd "C-x /") #'dabbrev-expand)
      (global-set-key (kbd "C-x ,") #'delete-region)
      (global-set-key (kbd "M-;") #'comment-dwim)
      (global-set-key (kbd "C-x C-b") #'ibuffer)
      (global-set-key (kbd "C-_") #'redo)
      (global-set-key (kbd "M-y") #'consult-yank-pop)

      (global-set-key (kbd "C-<tab>") #'completion-at-point)
      (global-set-key (kbd "M-i") #'backward-paragraph)
      (global-set-key (kbd "M-o") #'forward-paragraph)

      (global-set-key (kbd "C-c l") #'org-store-link)
      (global-set-key (kbd "C-c c")  #'my:org-capture)
      (global-set-key (kbd "C-;") #'switch-to-buffer)
      (global-set-key (kbd "<f2>") nil))

    (leaf *map-local
      :config
      (define-key read-expression-map (kbd "TAB") #'lisp-complete-symbol)

      (define-key isearch-mode-map (kbd "C-h") #'isearch-delete-char)))
#+end_src

** 標準処理に対するadvice
#+begin_src emacs-lisp
  (leaf *advices
    :config
    (defun my:no-kill-new-duplicate (yank &optional _)
      "kill-ringにおなじ内容が保存されないようにする"
      (setq kill-ring (delete yank kill-ring)))
    (advice-add 'kill-new :before #'my:no-kill-new-duplicate))
#+end_src

** OSごとの設定
#+begin_src emacs-lisp
  (when window-system
    (cond
     ((eq window-system 'x)
      ;; window-systemがxの場合に実行される初期化elisp
      ;; x11を利用している場合、クリップボードの連携を有効にする。
      (setq select-enable-clipboard t
            select-enable-primary nil))
     ((eq window-system 'pgtk)
      (setq my:wl-copy-process nil)
      (defun my:wl-copy (text)
        (setq my:wl-copy-process (make-process :name "wl-copy"
                                               :buffer nil
                                               :command '("wl-copy" "-f" "-n")
                                               :connection-type 'pipe
                                               :noquery t))
        (process-send-string my:wl-copy-process text)
        (process-send-eof my:wl-copy-process))
      (defun my:wl-paste ()
        (if (and my:wl-copy-process (process-live-p my:wl-copy-process))
            nil ; should return nil if we're the current paste owner
          (shell-command-to-string "wl-paste -n | tr -d \r")))
      (setq interprogram-cut-function #'my:wl-copy)
      (setq interprogram-paste-function #'my:wl-paste)
      )))
#+end_src

** leader key専用のキーマップ定義
general.elを利用しないでシンプルな管理方法に落ち着いた。結局こっちの方が柔軟性も視認性も高いし。

#+begin_src emacs-lisp
  (leaf *global-user
    :config
    (defvar my:global-user-mode-keymap (make-sparse-keymap))
    (define-key my:global-user-mode-keymap (kbd ";" ) #'persp-switch-to-buffer*)
    (define-key my:global-user-mode-keymap (kbd "p" ) 'projectile-command-map)
    (define-key my:global-user-mode-keymap (kbd "w" ) #'save-buffer)
    (define-key my:global-user-mode-keymap (kbd "s") #'my:consult-search-dwim)
    (define-key my:global-user-mode-keymap (kbd "r" ) #'my:deepl-translate)
    (define-key my:global-user-mode-keymap (kbd "hf") #'hydra-flycheck/body)
    (define-key my:global-user-mode-keymap (kbd "ho") #'hydra-org/body)
    (define-key my:global-user-mode-keymap (kbd "q" ) #'kill-current-buffer)
    ;; for org-mode
    (define-key my:global-user-mode-keymap (kbd "oc") #'org-capture)
    (define-key my:global-user-mode-keymap (kbd "or") #'org-roam-capture)
    (define-key my:global-user-mode-keymap (kbd "oj") #'org-roam-dailies-capture-today)
    (define-key my:global-user-mode-keymap (kbd "od") #'my:org-done-todo)
    (define-key my:global-user-mode-keymap (kbd "os") #'org-toggle-narrow-to-subtree)
    ;; shortcut for major functions
    (define-key my:global-user-mode-keymap (kbd "d" ) #'dired-jump)
    (define-key my:global-user-mode-keymap (kbd "e" ) #'find-file)
    (define-key my:global-user-mode-keymap (kbd "b" ) #'ibuffer)
    (define-key my:global-user-mode-keymap (kbd "#" ) #'server-edit)
    (define-key my:global-user-mode-keymap (kbd "m" ) #'magit-status)
    (define-key my:global-user-mode-keymap (kbd "f" ) #'projectile-find-file)
    (define-key my:global-user-mode-keymap (kbd "tt") #'treemacs-select-window)
    (define-key my:global-user-mode-keymap (kbd "tq") #'treemacs-quit)
    ;; 'l' is head character of operations for 'lint'
    (define-key my:global-user-mode-keymap (kbd "ll") #'langtool-check)
    (define-key my:global-user-mode-keymap (kbd "lL") #'langtool-check-done)
    ;; 'c' is head character of 'consult
    (define-key my:global-user-mode-keymap (kbd "cs") #'my:consult-search-dwim)
    (define-key my:global-user-mode-keymap (kbd "ci") #'consult-imenu)
    (define-key my:global-user-mode-keymap (kbd "coh") #'consult-org-heading)
    (define-key my:global-user-mode-keymap (kbd "cf") #'consult-git-grep)
    (define-key my:global-user-mode-keymap (kbd "cb") #'consult-buffer)
    (define-key my:global-user-mode-keymap (kbd "ch") #'consult-recent-file)
    ;; 'v' is head character of operations for 'persp'
    (define-key my:global-user-mode-keymap (kbd "vs") #'persp-switch)
    (define-key my:global-user-mode-keymap (kbd "vk") #'persp-kill)
    )
#+end_src

* ユーザー定義
** 便利関数など
#+begin_src emacs-lisp
  (leaf *utility-functions
    :hook
    (after-save-hook . my:after-save-hook)
    :preface
    (defun my:buffer-name-list ()
      "Get list of buffer name"
      (mapcar (function buffer-name) (buffer-list)))

    (defun my:delete-trailing-whitespace ()
      "delete trailing whitespace if the buffer is associated a major mode in `my:trailing-whitespace-exclude-modes'"
      (unless (seq-some (lambda (x) (eq major-mode x)) my:trailing-whitespace-exclude-modes)
        (delete-trailing-whitespace)))

    (defun my:after-save-hook ()
      "自作の保存時のhook"
      (run-hooks 'my:save-buffer-hook))

    (defun my:minor-mode-active-p (mode)
      "return specified minor mode is active or not"
      (let ((active-modes (cl-remove-if-not (lambda (it) (and (boundp it) (symbol-value it))) minor-mode-list)))
        (member mode active-modes)))

    (defun my:copy-with-system-clipboard (str)
      "Copy passed string to system clipboard.
  This function does not add `str' to the kill ring."
      (when (display-graphic-p)
        (cond
         ((eq system-type 'darwin)
          (let ((proc (make-process :name "pbcopy" :buffer nil :command '("pbcopy") :connection-type 'pipe)))
            (process-send-string proc str)
            (process-send-eof proc)
            (kill-process proc)))
         ((and (eq system-type 'gnu/linux)
               (eq window-system 'pgtk)
               (executable-find "wl-copy"))
          (let ((proc (make-process :name "wl-copy"
                                    :buffer nil
                                    :command '("wl-copy" "-f" "-n")
                                    :connection-type 'pipe)))
            (process-send-string proc str)
            (process-send-eof proc)
            (kill-process proc)))
         (t
          nil)
         )))
    )
#+end_src

** 既存機能の拡張
*** kill-regionの拡張
#+begin_src emacs-lisp
  (leaf *extend-kill-region
    :config
    (defun my:kill-word-or-kill-region (f &rest args)
      "kill-regionにおいて、リージョンが選択されていない場合にはbackward-kill-wardを実行するように。"
      (if (and (called-interactively-p 'interactive) transient-mark-mode (not mark-active))
          (backward-kill-word 1)
        (apply f args)))

    (advice-add 'kill-region :around 'my:kill-word-or-kill-region))
#+end_src

*** kill-lineの拡張
#+begin_src emacs-lisp
  (leaf *extend-kill-line
    :config
    (defun my:kill-line-and-fixup (f &rest args)
      "kill-lineの際に、次の行の行頭に連続している空白を削除する"
      (if (and (not (bolp)) (eolp))
          (progn
            (forward-char)
            (fixup-whitespace)
            (backward-char))
        (apply f args)))

    (advice-add 'kill-line :around 'my:kill-line-and-fixup))
#+end_src

*** downcase/upcase-char
なぜかこの処理が存在しなかったので追加する。

#+begin_src emacs-lisp
  (leaf *upcase-char
    :config
    (defun my:upcase-char ()
      "upcase current point character"
      (interactive)
      (save-excursion
        (let* ((current-point (point))
               (upcased (s-upcase (buffer-substring-no-properties current-point (1+ current-point)))))
          (replace-region-contents current-point (1+ current-point) (lambda () upcased)))))

    (defun my:downcase-char ()
      "downcase current point character"
      (interactive)
      (save-excursion
        (let* ((current-point (point))
               (downcased (s-downcase (buffer-substring-no-properties current-point (1+ current-point)))))
          (replace-region-contents current-point (1+ current-point) (lambda () downcased))))))
#+end_src

*** 単語単位のkill
#+begin_src emacs-lisp
  (defun my:kill-word-at-point ()
    "delete word at under cursor. If spaces was under the cursor, delete horizontal spaces"
    (interactive)
    (let ((char (char-to-string (char-after (point)))))
      (cond
       ((string= " " char) (delete-horizontal-space))
       ((string-match "[\t\n -@\[-`{-~]" char) (kill-word 1))
       (t (forward-char) (backward-word) (kill-word 1)))))
#+end_src

*** ファイルシステム関連
#+begin_src emacs-lisp
  (defun my:th-rename-tramp-buffer ()
    "trampで開いたファイルについて、バッファ名を変更する"
    (when (file-remote-p (buffer-file-name))
      (rename-buffer
       (format "%s:%s"
               (file-remote-p (buffer-file-name) 'method)
               (buffer-name)))))

  (defun my:th-find-file-sudo (file)
    "Opens FILE with root privileges."
    (interactive "F")
    (set-buffer (find-file (concat "/sudo::" file))))

  (add-hook 'find-file-hook #'my:th-rename-tramp-buffer)
#+end_src

*** scratchバッファの拡張
#+begin_src emacs-lisp
  (leaf *scratch-expansion
    :config
    ;; (@> "*scratch*をkillできないようにする")
    (defun my:make-scratch (&optional arg)
      "scratchバッファをkillできないようにする"
      ;; "*scratch*" を作成して buffer-list に放り込む
      (set-buffer (get-buffer-create "*scratch*"))
      (funcall initial-major-mode)
      (erase-buffer)
      (when (and initial-scratch-message (not inhibit-startup-message))
        (insert initial-scratch-message))
      (or arg (progn (setq arg 0)
                     (switch-to-buffer "*scratch*")))
      (cond ((= arg 0) (message "*scratch* is cleared up."))
            ((= arg 1) (message "another *scratch* is created"))))

    (defun my:clear-scratch-when-kill-buffer ()
      (if (string= "*scratch*" (buffer-name))
          (progn (my:make-scratch 0) nil)
        t))

    ;; *scratch* バッファで kill-buffer したら内容を消去するだけにする
    (add-hook 'kill-buffer-query-functions #'my:clear-scratch-when-kill-buffer))
#+end_src

*** 補完中は保存を実行しない
色々と問題が出るケースがあるので、corfuを利用する前提で無効化する。

#+begin_src emacs-lisp  (leaf *save-buffer-advice
  (leaf *save-buffer
    :config
    (defun my:dont-save-buffer-around-completion (f &rest args)
      "save-buffer時に補完が動いていたら保存しない"
      (unless completion-in-region-mode
        (apply f args)))

    (advice-add 'save-buffer :around 'my:dont-save-buffer-around-completion))
#+end_src

** deepl連携
deeplと連携して、翻訳した文章をコピペするための処理を提供する。

#+begin_src emacs-lisp
  (defcustom my:deepl-auth-key nil
    "Auth key for deepl"
    :group 'my
    :type '(string))

  (defcustom my:deepl-api-host "api-free.deepl.com"
    "The host for deepl API. Use `api-free' when your plan is free."
    :type 'string
    :group 'my)

  (defcustom my:deepl-send-confirmation-threshold 3000
    "Threshold of string before sending deepl"
    :type 'string
    :group 'my)

  (leaf *deepl
    :config

    (leaf request :straight t)

    (cl-defun my:deepl-send-string-confirm (&key retry)
      "Do confirmation before sending large string to deepl."
      (y-or-n-p (format "It's over %d characters, do you really want to send it" my:deepl-send-confirmation-threshold)))

    (cl-defun my:deepl-translate-internal (text source-lang target-lang callback)
      "Call deepl translate with confirmation."
      (when (and (> (length text) my:deepl-send-confirmation-threshold)
                 (not (my:deepl-send-string-confirm)))
        (cl-return-from my:deel-translate-internal))

      (request (format "https://%s/v2/translate" my:deepl-api-host)
        :method "POST"
        :data `(
                ("auth_key" . ,my:deepl-auth-key)
                ("text" . ,text)
                ("source_lang" . ,source-lang)
                ("target_lang" . ,target-lang))
        :parser 'json-read
        :success callback))

    (cl-defun my:deepl-output-message (&key data &allow-other-keys)
      "Output and kill message with temporary buffer."
      (save-excursion
        (with-temp-buffer
          (switch-to-buffer (current-buffer))
          (let ((translated-text (cdr (assoc 'text (aref (cdr (assoc 'translations data)) 0)))))
            (insert translated-text)
            (when (y-or-n-p "Use this translation?")
              (kill-new translated-text))))))

    (defun my:japanese-character-p (char)
      (or (<= #x3041 char #x309f) ; hiragana
          (<= #x30a1 char #x30ff) ; katakana
          (<= #x4e01 char #x9faf) ; kanji
          ))

    (defun my:deepl-translate (start end)
      "Translate region via deepl."
      (interactive "r")
      (let ((region (buffer-substring-no-properties start end)))
        ;; 3文字以上日本語が含まれている場合は日本語と判断する。
        (if (>= (cl-count-if #'my:japanese-character-p region) 3)
            (my:deepl-translate-internal region "JA" "EN" #'my:deepl-output-message)
          (my:deepl-translate-internal region "EN" "JA" #'my:deepl-output-message))))
    )
#+end_src

* フォントの設定
色々難しいところなので、ここはleafでラップする。

#+begin_src emacs-lisp
  (leaf *font
    :after nerd-icons
    :preface
    (defun my:font-initialize (&optional font-size)
      "Initialize fonts on window-system"
      (interactive "P")

      (let ((font-size (if font-size
                           (read-minibuffer "Font Size:")
                         my:font-size)))
        (when window-system
          (cond
           ((eq window-system 'ns)
            (let* ((size (or font-size my:font-size))
                   (asciifont my:font-family)
                   (jpfont my:font-family)
                   (h (round (* size 10)))
                   (fontspec)
                   (jp-fontspec))
              (set-face-attribute 'default nil :family asciifont :height h)
              (setq fontspec (font-spec :family asciifont))
              (setq jp-fontspec (font-spec :family jpfont))
              (set-fontset-font nil 'japanese-jisx0208 jp-fontspec)
              (set-fontset-font nil 'japanese-jisx0212 jp-fontspec)
              (set-fontset-font nil 'japanese-jisx0213-1 jp-fontspec)
              (set-fontset-font nil 'japanese-jisx0213-2 jp-fontspec)
              (set-fontset-font nil '(#x0080 . #x024F) fontspec)
              (set-fontset-font nil '(#x0370 . #x03FF) fontspec)
              (when (featurep 'nerd-icons)
                (set-fontset-font nil 'unicode (font-spec :family nerd-icons-font-family) nil 'append))
              (message (format "Setup for %s with %f" asciifont size))))
           ((or (eq window-system 'x) (eq window-system 'pgtk))
            (let* ((size (or font-size my:font-size))
                   (asciifont my:font-family)
                   (jpfont my:font-family)
                   (h (round (* size 10)))
                   (jp-fontspec (font-spec :family jpfont)))
              (when (featurep 'nerd-icons)
                (set-fontset-font nil 'unicode (font-spec :family nerd-icons-font-family) nil 'append))
              (set-face-attribute 'default nil :family asciifont :height h)
              (unless (string= asciifont jpfont)
                (set-fontset-font nil 'unicode jp-fontspec nil))
              (message (format "Setup for %s with %f" asciifont size))))
           (t
            (message "Not have window-system"))))))
    :config
    (leaf *font-hook
      :if (window-system)
      :hook
      (emacs-startup-hook . my:font-initialize)))
#+end_src

* init.org関連の設定
#+begin_src emacs-lisp
  (leaf *for-init-org
    :after org
    :config
    (defun my:restore-init.el ()
      (when (string=
             (expand-file-name "init.org" user-emacs-directory)
             (buffer-file-name))
        (with-temp-buffer
          (insert ";; -*- coding: utf-8 -*-")
          (newline)
          (insert (prin1-to-string my:init.el-content))
          (write-file (expand-file-name "init.el" user-emacs-directory) nil))))

    (add-hook 'my:save-buffer-hook #'my:restore-init.el))
#+end_src

* package設定
原則は、1packageにつき1見出しであり、関連するパッケージはleaf側でくくるようにする。

major-modeなどという単位は、org側のoutlineで設定するようにする。

** hydra
#+begin_src emacs-lisp
  (leaf hydra :straight t)
#+end_src

** diminish
#+begin_src emacs-lisp
  (leaf diminish :straight t :require t)
#+end_src

** major-modes
*** org
#+begin_src emacs-lisp
  (leaf *org-mode
    :config
    (leaf org
      :straight t
      :mode ("\\.org\\'" . org-mode)
      :hook (org-mode-hook . turn-on-font-lock)
      :custom (;; org-mode内部のソースを色付けする
               (org-src-fontify-natively . t)
               ;; org-modeの開始時に、行の折り返しを無効にする。
               (org-startup-truncated . t)
               ;; follow-linkから戻ることを可能とする。
               (org-return-follows-link . t)
               ;; 自動的にタグをalignしない
               (org-auto-align-tags . nil)
               (org-tags-column . 0)
               (org-catch-invisible-edits . 'show-and-error)
               ;; 先頭にあるstarを隠す
               (org-hide-leading-stars . t)
               ;; org特有のCtrl-a/eの挙動を使う
               (org-special-ctrl-a/e . t)
               ;; 現在のsubtreeの後にheadingを追加するようにする
               (org-insert-heading-respect-content . t)

               ;; UTF8にあるentitiesを利用するようにする
               (org-prettiy-entities . t)
               ;; outlineのellipsisで使う文字を指定する
               (org-ellipsis . "…")
               (org-refile-use-outline-path . 'file)
               (org-outline-path-complete-in-steps . nil)
               (org-log-done . 'time)
               (org-todo-keywords . '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)" "CANCELED(c)")))

               (org-adapt-indentation . t)
               (org-clock-clocked-in-display . 'none)
               (org-clock-out-remove-zero-time-clocks . t)

               (org-structure-template-alist . '(("s" . "src")
                                                 ("e" . "example")
                                                 ("c" . "center")
                                                 ("q" . "quote")
                                                 ("v" . "verse")
                                                 ("C" . "comment")
                                                 ("E" . "export")
                                                 ("l" . "src emacs-lisp")
                                                 ("h" . "export html")
                                                 ("a" . "export ascii"))))

      :config
      (leaf ob-plantuml
        :require t
        :config
        (setq org-plantuml-jar-path (expand-file-name (locate-user-emacs-file "plantuml.jar")))
        (add-to-list 'org-babel-load-languages '(plantuml . t)))

      (leaf *org-local-functions
        :hook
        (my:save-buffer-hook . my:org-roam-project-update-tag)
        :init
        (defun my:org-capture ()
          "do capture fastest"
          (interactive)
          (org-capture nil "t"))

        (defun my:org-done-todo ()
          (interactive)
          (org-todo "DONE"))

        (defun my:org-current-is-todo ()
          (string= "TODO" (org-get-todo-state)))

        (defun my:org-roam-buffer-p (&optional buffer)
          "Return boolean that current buffer is roam buffer or not"
          (with-current-buffer (or buffer (current-buffer))
            (and buffer-file-name
                 (string= (expand-file-name (file-name-as-directory my:org-roam-directory))
                          (expand-file-name (file-name-directory buffer-file-name))))))

        (defun my:org-roam-project-file-p (&optional buffer)
          "Return non-nil if current buffer has any todo entry"
          (org-element-map
              (org-element-parse-buffer 'headline)
              'headline
            (lambda (e) (eq (org-element-property :todo-type e) 'todo))
            nil 'first-match))

        (defun my:org-roam-update-roam-tags (&rest tags)
          "Update filetags with TAGS list"
          (let* ((tags (combine-and-quote-strings tags " ")))
            (my:org-set-keyword "filetags" tags)))

        (defun my:org-roam-project-update-tag ()
          "Update PROJECT tag in the current buffer."
          (when (and (not (active-minibuffer-window))
                     (my:org-roam-buffer-p))
            (save-excursion
              (goto-char (point-min))
              (let* ((tags (or (my:org-get-keyword "filetags") ""))
                     (tags (--map (s-replace-all '(("\"" . "")) it) (s-split " " tags)))
                     (original-tags tags))
                (if (my:org-roam-project-file-p)
                    (setq tags (seq-uniq (cons "project" tags)))
                  (setq tags (remove "project" tags)))
                (unless (equal original-tags tags)
                  (apply #'my:org-roam-update-roam-tags tags))))))

        (defun my:org-roam-project-files ()
          "Return a list of note files containing 'project' tag." ;
          (seq-uniq
           (seq-map
            #'car
            (org-roam-db-query
             [:select [nodes:file]
                      :from tags
                      :left-join nodes
                      :on (= tags:node-id nodes:id)
                      :where (like tag (quote "%\"project\"%"))]))))

        (defun my:org-agenda-files-update (&rest _)
          "Update the value of `org-agenda-files'."
          (setq org-agenda-files (my:org-roam-project-files))
          (add-to-list 'org-agenda-files (expand-file-name "inbox.org" my:org-roam-directory)))

        (advice-add 'org-agenda :before #'my:org-agenda-files-update)

        (defun my:org-set-keyword (keyword value &optional buffer)
          "Add or replace VALUE of KEYWORD of org-mode to current buffer. "
          (save-excursion
            (with-current-buffer (or buffer (current-buffer))
              (let* ((org-tree (org-element-parse-buffer))
                     (el (org-element-map
                             org-tree
                             'keyword
                           (lambda (el) (let ((keyword-in-el (org-element-property :key el)))
                                          (and (string-match-p keyword keyword-in-el)
                                               el)))
                           nil 'first-match)))
                (when el
                  (delete-region (org-element-property :begin el) (org-element-property :end el))
                  (setq org-tree (org-element-parse-buffer)))

                (let* ((first-keyword (org-element-map org-tree 'keyword #'identity nil t))
                       (el (if (not el)
                               (let* ((el (org-element-create 'keyword))
                                      (el (org-element-put-property el :key keyword))
                                      (el (org-element-put-property el :value value)))
                                 (goto-char (1+ (org-element-property :end first-keyword)))
                                 (newline)
                                 (insert (org-element-interpret-data el)))
                             (org-element-put-property el :value value))))

                  (goto-char (org-element-property :end first-keyword))
                  (insert (org-element-interpret-data el))
                  (save-buffer))))))

        (defun my:org-get-keyword (keyword &optional buffer)
          "Get KEYWORD from BUFFER or current buffer. You can use regexp or raw string for KEYWORD."
          (with-current-buffer (or buffer (current-buffer))
            (let ((el (org-element-map
                          (org-element-parse-buffer)
                          'keyword
                        (lambda (el)
                          (when (string-match-p (s-upcase keyword) (org-element-property :key el)) el)) nil 'first-match)))
              (when el
                (org-element-property :value el)))))

        (defun my:org-global-props (&optional property buffer)
          "Get the plists of global org properties of current buffer."
          (unless property (setq property "PROPERTY"))
          (with-current-buffer (or buffer (current-buffer))
            (org-element-map
                (org-element-parse-buffer)
                'keyword
              (lambda (el) (when (string-match property (org-element-property :key el)) el)))))

        (defun my:org-add-ymd-to-archive (name)
          "replace anchor to YYYY-MM string"
          (let* ((ymd (format-time-string "%Y-%m")))
            (replace-regexp-in-string "#YM" ymd name)))
        (advice-add 'org-extract-archive-file :filter-return #'my:org-add-ymd-to-archive))

      (leaf *refile-settings
        :config
        (let ((project (expand-file-name "project.org" my:org-roam-directory)))
          (setq org-refile-targets
                `((,project :maxlevel . 1)))))

      (leaf *capture-settings
        :if my:org-roam-directory
        :config
        (let ((inbox (expand-file-name "inbox.org" my:org-roam-directory)))
          (setq org-capture-templates
                `(("t" "todo" plain (file ,inbox)
                   "* TODO %?\n%U\n" :clock-resume t))))

        (defun my:org-set-archive-name-for-month (&rest args)
          (setq-local org-archive-location (concat "./archives/"
                                                   (format-time-string "%Y%m" (current-time))
                                                   "-%s_archive::datetree/* Finished Tasks")))

        (advice-add 'org-archive-subtree :before #'my:org-set-archive-name-for-month))

      (leaf *org-hydra
        :after hydra
        :config
        (defhydra hydra-org ()
          "
            Navigate Heads^^
            ---------------------------------------------------
            [_k_] Prev visible [_l_] Visibility Cycle
            [_j_] Next visible
            [_u_] Up level
            [_K_] Prev sibling
            [_J_] Next sibling
            ---------------------------------------------------
                    [_q_] Quit
            "
          ("J" org-forward-heading-same-level)
          ("K" org-backward-heading-same-level)
          ("j" org-next-visible-heading)
          ("k" org-previous-visible-heading)
          ("u" outline-up-heading)
          ("l" org-cycle)
          ("q" nil))))

    (leaf org-agenda
      :require t
      :if my:org-roam-directory
      :bind
      ("C-c a" . org-agenda)
      :custom
      (org-agenda-custom-commands . '((" " "Agenda"
                                       ((tags
                                         "REFILE"
                                         ((org-agenda-overriding-header "To refile")
                                          (org-tags-match-list-sublevels nil)))
                                        (tags
                                         "PROJECT"
                                         ((org-agenda-overriding-header "To project")
                                          (org-tags-match-list-sublevels nil)))))))
      (org-agenda-current-time-string . "← now")
      (org-agenda-time-grid . '((daily today require-timed)
                                (0700 0800 0900 01000 1100 1200 1300 1400 1500 1600 1700 1800 1900 2000 2100 2200 2300 2400)
                                "-"
                                "────────────────"))
      (org-agenda-prefix-format . '((agenda . " %i %-15(my:org-agenda-category 15)%?-12t%s")
                                    (todo . " %i %-15(my:org-agenda-category 15) ")
                                    (tags . " %i %-15(my:org-agenda-category 15) ")
                                    (search . " %i %-15(my:org-agenda-category 15) ")))

      (org-agenda-clockreport-parameter-plist . '(
                                                  :maxlevel 5
                                                  :block t
                                                  :tstart t
                                                  :tend t
                                                  :emphasize t
                                                  :link t
                                                  :narrow 80
                                                  :indent t
                                                  :formula nil
                                                  :level 5
                                                  :tcolumns nil
                                                  :properties ("CATEGORY")
                                                  :hidefiles t))
      :config
      (defun my:org-agenda-category (&optional len)
        "Get category of item at point for agenda.

  Category is defined by one of the following items:

  - CATEGORY property
  - TITLE keyword
  - TITLE property
  - filename without directory and extension

  When LEN is a number, resulting string is padded right with
  spaces and then truncated with ... on the right if result is
  longer than LEN.

  Usage example:

    (setq org-agenda-prefix-format
          '((agenda . \" %(my:org-agenda-category) %?-12t %12s\")))

  Refer to `org-agenda-prefix-format' for more information."
        (let* ((file-name (when buffer-file-name
                            (file-name-sans-extension
                             (file-name-nondirectory buffer-file-name))))
               (title (my:org-get-keyword "title"))
               (category (org-get-category))
               (result
                (or (if (and
                         title
                         (string-equal category file-name))
                        title
                      category)
                    "")))
          (if (numberp len)
              (s-truncate len (s-pad-right len " " result))
            result))))

    (leaf org-clock
      :leaf-defer nil
      :require t
      :hook (org-clock-out-hook . org-update-all-dblocks)
      :custom
      (org-clock-out-remove-zero-time-clocks . t)
      (org-clock-clocked-in-display . 'frame-title)
      (org-clock-frame-title-format . '((:eval (format "%s %s"
                                                       (if (require 'org-clock-today nil t)
                                                           (if org-clock-today-count-subtree
                                                               (format "%s / %s"
                                                                       org-clock-today-subtree-time
                                                                       org-clock-today-buffer-time)
                                                             (format "%s" org-clock-today-buffer-time))
                                                         "")
                                                       org-mode-line-string))))
      :hook (kill-emacs-hook . my:org-clock-out-and-save-when-exit)
      :preface
      (defun my:org-clock-out-and-save-when-exit ()
        "Save buffers and stop clocking when kill emacs."
        (when (org-clocking-p)
          (org-clock-out)
          (save-some-buffers t)))
      :config
      (defun my:task-clocked-time ()
        (interactive)
        (let* ((clocked-time (org-clock-get-clocked-time))
               (h (truncate clocked-time 60))
               (m (mod clocked-time 60))
               (work-done-str (format "%d:%02d" h m)))
          (if org-clock-effort
              (let* ((effort-in-minutes
                      (org-duration-to-minutes org-clock-effort))
                     (effort-h (truncate effort-in-minutes 60))
                     (effort-m (truncate (mod effort-in-minutes 60)))
                     (effort-str (format "%d:%02d" effort-h effort-m)))
                (format "%s/%s" work-done-str effort-str))
            (format "%s" work-done-str))))

      (defun my:update-task-clocked-time ()
        (setq my:org-clocked-time-mode-line (my:task-clocked-time))))

    (leaf ox-hugo
      :straight t
      :hook
      (org-mode-hook . my:org-hugo-enable-if-hugo-buffer)
      :preface
      (defun my:org-hugo-enable-if-hugo-buffer ()
        (let ((prop (my:org-global-props "HUGO_.\+" (current-buffer))))
          (when prop
            (org-hugo-auto-export-mode +1)))))

    (leaf org-onit
      :after org-clock org
      :straight (org-onit :type git :host github :repo "takaxp/org-onit")
      :bind
      (("C-<f11>" . org-clock-goto)
       (:org-mode-map
        :package org
        ("<f11>" . org-onit-toggle-doing)
        ("S-<f11>" . org-onit-goto-anchor))))

    (leaf org-clock-today
      :straight t
      :after org-clock
      :config
      (org-clock-today-mode 1))

    (leaf org-tempo
      :leaf-defer nil
      :require t))
#+end_src

**** org-roam
#+begin_src emacs-lisp
  (leaf org-roam
    :after (org)
    :straight (org-roam :type git :host github :repo "org-roam/org-roam")
    :if (and (file-exists-p my:org-roam-directory))
    :custom
    ((org-roam-db-update-method . 'immediate)
     (org-roam-db-location . my:org-roam-db-location)
     (org-roam-directory . my:org-roam-directory)
     (org-roam-index-file . my:org-roam-index-file)
     (org-roam-dailies-directory . my:org-roam-dailies-directory)
     (org-roam-database-connector . 'sqlite-builtin)
     (org-roam-v2-ack . t)
     (org-roam-capture-ref-templates . '(("r" "ref" plain "%?"
                                          :if-new (file+head "%<%Y-%m-%d--%H-%M-%SZ>--${slug}.org" "#+title: ${title}\n#+filetags: \n#+roam_key: ${ref}")
                                          :unnarrowed t)))
     (org-roam-capture-templates . '(("d" "default" plain
                                      "%?"
                                      :if-new (file+head "%<%Y-%m-%d--%H-%M-%SZ>--${slug}.org" "#+title: ${title}\n#+filetags: \n")
                                      :unnarrowed t)))
     (org-roam-dailies-capture-templates . '(("d" "default" entry
                                              "%?"
                                              :if-new (file+head "dayly/%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n")
                                              :olp ("Journal")))))
    :bind
    (:org-mode-map
     :package org
     ("C-c r" . org-roam-node-insert)
     ("C-c t" . org-roam-tag-add))
    :hook
    (after-init-hook . org-roam-db-autosync-mode))
#+end_src

***** emacsql-sqlite-builtin
emacsqlのバックエンドとしてsqliteを使うが、使うsqliteとしてemacsにbuiltinされているものを使う、というやつ。

#+begin_src emacs-lisp
  (leaf emacsql-sqlite-builtin :straight t)
#+end_src
**** org-modern
org-modeの表現をモダンなものにしてくれるパッケージ。variable pitch的な挙動になるので、結構気をつける必要がある。
#+begin_src emacs-lisp
  (leaf org-modern :straight t
    :after org
    :custom
    (org-modern-block-fringe . t)
    ;; UDEV Gothicだとガタつくので、ガタつかないのと視覚的にわかりやすいものを使う
    (org-modern-star . 'replace)
    (org-modern-replace-stars . "①②③④⑤")
    (org-modern-hide-stars . nil)
    :hook
    (org-mode-hook . org-modern-mode))
#+end_src
*** go-mode
#+begin_src emacs-lisp
  (leaf go-mode
    :straight t
    :bind (:go-mode-map
           ("M-." . godef-jump))
    :hook
    (go-mode-hook . my:go-mode-hook-1)
    :config
    ;; go.modがある場所をrootとする
    (defun my:project-find-go-module (dir)
      (when-let ((root (locate-dominating-file dir "go.mod")))
        (cons 'go-module root)))

    (cl-defmethod project-root ((project (head go-module)))
      (cdr project))

    (defun my:go-mode-hook-1 ()
      ;; そのバッファでのみ有効にする
      (add-hook 'project-find-functions #'my:project-find-go-module 0 t)

      (eglot-ensure)))
#+end_src

*** common lisp

**** lisp-mode
#+begin_src emacs-lisp
  (leaf lisp-mode
    :require t
    :preface
    (defun my:lisp-hooks ())
    :hook
    (lisp-mode-hook . my:lisp-hooks))
#+end_src

**** roswell
#+begin_src emacs-lisp
  (leaf *roswell
    :if (let ((helper (expand-file-name "helper.el" my:roswell-path)))
          (and (file-exists-p helper) my:roswell-path))
    :config
    (defvar roswell-slime-contribs '(slime slime-fancy))
    (load helper)

    (defun slime-qlot-exec (directory)
      "start slime with qlot"
      (slime-start :program "qlot"
                   :program-args '("exec" "ros" "-S" "." "run")
                   :directory directory
                   :name 'qlot
                   :env (list (concat "PATH="
                                      (mapconcat 'identity exec-path ":"))
                              (concat "QUICKLISP_HOME="
                                      (file-name-as-directory directory) "quicklisp/"))))

    (defun slime-qlot (directory)
      "start slime with qlot"
      (interactive (list (read-directory-name "Project directory: ")))
      (slime-qlot-exec directory))

    (defun slime-qlot-restart (directory)
      (interactive (list (read-directory-name "Project directory: ")))
      (ignore-errors
        (let* ((buffer (get-buffer "*inferior-lisp*"))
               (process (get-buffer-process buffer)))
          (when (and buffer process)
            (set-process-query-on-exit-flag process nil)
            (kill-buffer buffer))))
      (slime-qlot-exec directory)))
#+end_src

**** hyperspec
#+begin_src emacs-lisp
  (leaf hyperspec
    :when (featurep 'slime)
    :require t
    :custom
    ;; HyperSpecをewwで見る設定
    (common-lisp-hyperspec-root . "~/.emacs.d/share/HyperSpec/")

    :config
    (unless (file-exists-p (expand-file-name "~/.emacs.d/share/HyperSpec"))
      (when (eq window-system 'x)

        (make-directory (expand-file-name "~/.emacs.d/share") t)
        (let ((hyperspec-url "ftp://ftp.lispworks.com/pub/software_tools/reference/HyperSpec-7-0.tar.gz")
              (output "/tmp/HyperSpec.tar.gz"))

          (call-process "curl" nil nil t "-L" "-o" output hyperspec-url)
          (shell-command (format "tar zxvf %s -C %s" output "~/.emacs.d/share")))))

    ;; redefine function
    (defun common-lisp-hyperspec (symbol-name)
      (interactive (list (common-lisp-hyperspec-read-symbol-name)))
      (let ((buf (current-buffer)))
        (let ((name (common-lisp-hyperspec--strip-cl-package
                     (downcase symbol-name))))
          (cl-maplist (lambda (entry)
                        (eww-open-file (concat common-lisp-hyperspec-root "Body/"
                                               (car entry)))
                        (when (cdr entry)
                          (sleep-for 1.5)))
                      (or (common-lisp-hyperspec--find name)
                          (error "The symbol `%s' is not defined in Common Lisp"
                                 symbol-name))))
        (switch-to-buffer buf)
        (display-buffer "*eww*"))))
#+end_src

*** ruby
#+begin_src emacs-lisp
  (leaf ruby
    :config
    (leaf ruby-mode
      :require t
      :mode ("\\.rb$" . ruby-mode)
      :bind (:ruby-mode-map
             ("C-c x" . xmp)
             ("C-M-i" . rct-complete-symbol--anything)))

    (leaf ruby-end
      :straight t
      :hook (ruby-mode-hook . ruby-end-mode)))
#+end_src

*** rust-mode
Rust用のmajor mode

#+begin_src emacs-lisp
  (leaf rust-mode
    :straight t
    :custom
    (rust-indent-offset . 4)
    ;; formatterはcommit時にのみ実行するようにした方がよいので、機能をオフにする
    (rust-format-on-save . nil)
    :hook
    (rust-mode-hook . eglot-ensure)
    (rust-mode-hook . cargo-minor-mode))

  (leaf rust-ts-mode
    :require t
    :ensure t
    :custom
    (rust-ts-indent-offset . 4)
    :hook
    (rust-ts-mode-hook . my:rust-mode-hook)
    (rust-ts-mode-hook . cargo-minor-mode)
    :config
    (defun my:find-rust-project-root (dir)
      (when-let ((root (locate-dominating-file dir "Cargo.toml")))
        (list 'vc 'Git root)))

    (defun my:rust-mode-hook ()
      (setq-local project-find-functions (list #'my:find-rust-project-root))
      (eglot-ensure)))

  (leaf cargo
    :straight t)

  (leaf *rust-analyzer
    :after f
    :if (and my:cargo-path my:rust-analyzer-version)
    :init
    (let* ((cargo-path (expand-file-name "bin" my:cargo-path))
           (server-program (expand-file-name "rust-analyzer"  cargo-path)))
      (unless (f-exists-p server-program)
        (let* ((target (cond ((eq window-system 'ns) "apple-darwin")
                             (t "unknown-linux-gnu")))
               (path (format "https://github.com/rust-analyzer/rust-analyzer/releases/download/%s/rust-analyzer-x86_64-%s.gz" my:rust-analyzer-version target)))
          (call-process "curl" nil nil t "-L" path "-o" "/tmp/rust-analyzer.gz")
          (call-process "gunzip" nil nil t "/tmp/rust-analyzer.gz")
          (f-move "/tmp/rust-analyzer" server-program)
          (chmod server-program 0755)
          (message "Success rust-analyzer installation!")))))
#+end_src

*** python

**** pyvenv
venvを利用できるようにする。実際には、その時点で利用するvenvを変更する・・・みたいなこともできるみたいだが、まぁそこまではできなくてもいいかなっていう。

#+begin_src emacs-lisp
  (leaf pyvenv
    :straight t
    :if (and my:virtualenv-path (file-exists-p my:virtualenv-path))
    :config
    (pyvenv-activate my:virtualenv-path))
#+end_src

**** python mode
#+begin_src emacs-lisp
  (leaf python
    :mode ("\\.py$" . python-mode)
    :hook
    (python-mode-hook . my:python-mode-hook-0)
    :preface
    (defun my:python-mode-hook-0 ()
      (setq-local indent-tabs-mode nil)
      (pyvenv-mode +1)))
#+end_src

*** emacs-lisp
#+begin_src emacs-lisp
  (leaf elisp-mode
    :require t
    :after (cape)
    :preface
    (defun my:emacs-lisp-hooks ()
      (setq-local completion-at-point-functions
                  (list (cape-capf-case-fold
                         (cape-capf-super
                          #'tempel-complete
                          #'elisp-completion-at-point))))
      )

    :hook
    (emacs-lisp-mode-hook . my:emacs-lisp-hooks)
    :config
    (leaf eldoc
      :commands eldoc-mode
      :custom
      ;; idle時にdelayをかけない
      (eldoc-idle-delay . 0)
      ;; echo areaに複数行表示を有効にする
      (eldoc-echo-area-use-multiline-p . t)
      :hook
      (emacs-lisp-mode-hook . eldoc-mode)
      (lisp-interaction-mode-hook . eldoc-mode)
      (ielm-mode-hook . eldoc-mode)))
#+end_src

*** ocaml
OPAMの動作が前提なので、最初にOPAMにあるやつを読み込めるようにしておく。

#+begin_src emacs-lisp
  (eval-and-compile
    (defun my:opam-share-directory-p ()
      (let ((opam-share (ignore-errors (car (process-lines "opam" "config" "var" "share")))))
        (and opam-share (file-directory-p opam-share))))

    (defun my:opam-load-path ()
      (let ((opam-share (ignore-errors (car (process-lines "opam" "config" "var" "share")))))
        (when (and opam-share (file-directory-p opam-share))
          (expand-file-name "emacs/site-lisp" opam-share)))))

  (when (my:opam-share-directory-p)
    (add-to-list 'load-path (my:opam-load-path)))
#+end_src

**** ocamlformat
ocamlformatはOPAMで入って初めて使えるのだが、とりあえずはrequireしておく。

#+begin_src emacs-lisp
  (leaf ocamlformat
    :require t
    :if (my:opam-share-directory-p)
    :commands ocamlformat-before-save
    :custom
    (ocamlformat-show-errors . nil))
#+end_src

**** tuareg
caml-modeよりもこちらを利用する。

#+begin_src emacs-lisp
  (leaf tuareg
    :straight t
    :mode
    ;; ("\\.ml[ily]?\\'" . tuareg-mode)
    ;; ("\\.topml\\'" . tuareg-mode)
    :custom
    ;; Global tuareg setting
    ;; ただしインデント系統はocamlformatでフォーマットされるので、ほぼここにある設定は意味がなくなっている
    (tuareg-let-always-indent . t)
    (tuareg-function-indent . 0)
    (tuareg-match-indent . 0)
    (tuareg-sig-struct-indent . 0)
    (tuareg-match-patterns-aligned . t)
    :hook
    (tuareg-mode-hook . tuareg-mode-hook-1)
    :bind
    (:tuareg-mode-map ("C-c C-c" . my:dune-compile)
                      ;; caml-helpを潰しておく
                      ("C-h" . delete-backward-char))
    :preface
    (defun tuareg-mode-hook-1 ()
      (let ((bufname (buffer-name)))

        (electric-indent-mode 1)

        (eglot-ensure)))

    (defun my:dune-compile ()
      (interactive)
      (save-buffer)
      (let* ((default-directory
              (or (locate-dominating-file buffer-file-name "Makefile") default-directory))
             (compile-command (concat "(cd " default-directory " && dune build @check)"))
             (compilation-directory
              (or (locate-dominating-file buffer-file-name "Makefile") nil)))
        (recompile)))

    ;; use ocamllsp valid in eglot
    ;; https://github.com/joaotavora/eglot/issues/525
    (put 'tuareg-mode 'eglot-language-id "ocaml"))
#+end_src

**** ocaml-ts-mode
Emacs29から組み込まれたtreesitterのmoduleを前提としたもの。

#+begin_src emacs-lisp
  (leaf ocaml-ts-mode
    :straight (ocaml-ts-mode :type git :host github :repo "dmitrig/ocaml-ts-mode")
    :if (and (version<= "29" emacs-version) (featurep 'treesit))
    :mode
    ("\\.ml[ily]?\\'" . ocaml-ts-mode)
    ("\\.topml\\'" . ocaml-ts-mode)
    :hook
    (ocaml-ts-mode-hook . ocaml-ts-mode-hook-1)
    :bind
    (:ocaml-ts-mode-map 
     ;; caml-helpを潰しておく
     ("C-h" . delete-backward-char))
    :preface
    (defun ocaml-ts-mode-hook-1 ()
      (let ((bufname (buffer-name)))

        (electric-indent-mode 1)

        (eglot-ensure)))

    ;; use ocamllsp valid in eglot
    ;; https://github.com/joaotavora/eglot/issues/525
    (put 'ocaml-ts-mode 'eglot-language-id "ocaml"))
#+end_src
*** adoc-mode
asciidoc用のモード。ちょっと表示がうるさいのが玉に瑕。
#+begin_src emacs-lisp
  (leaf adoc-mode
    :straight t
    :mode ("\\.adoc\\'" . adoc-mode))
#+end_src

*** lua-mode
#+begin_src emacs-lisp
  (leaf lua-mode
    :straight t
    :mode ("\\.lua\\'" . lua-mode))
#+end_src

*** markdown-mode
#+begin_src emacs-lisp
  (leaf markdown-mode
    :straight t
    :mode ("\\.md\\'" . markdown-mode))
#+end_src

*** rst
わかりづらいが、reStructuredText。

#+begin_src emacs-lisp
  (leaf rst
    :require t
    :mode ("\\.rst\\'" . rst-mode))
#+end_src

*** css-mode
#+begin_src emacs-lisp
  (leaf css-mode
    :require t
    :mode
    (("\\.css\\'" . css-mode) ("\\.scss\\'" . scss-mode))
    :custom
    (scss-compile-at-save . nil)
    (css-indent-offset . 2)
    :hook
    (scss-mode-hook . my:scss-mode-hook-0)
    (css-mode-hook . my:scss-mode-hook-0)
    :preface
    (defun my:scss-mode-hook-0 ()
      (add-node-modules-path)

      (setq-local flycheck-check-syntax-automatically '(save mode-enabled))
      (setq-local flycheck-css-stylelint-executable "stylelint")
      (rainbow-mode +1)))
#+end_src

**** rainbow-mode
文字の名前やコードに対して色をつける。CSS書く場合はないと、一部の特殊な人間以外はわけわからなくなる。ただし問題としては、 hex形式  ~#xxx~ じゃないと表示できない。これはこれで結構辛いけど、まぁvariableのときくらいしか使わないというのはある。

#+begin_src emacs-lisp
  (leaf rainbow-mode
    :straight t)
#+end_src

*** yaml-mode
#+begin_src emacs-lisp
  (leaf yaml-mode
    :straight t
    :mode ("\\.yml\\'" . yaml-mode))
#+end_src

*** web-mode
jsxを使うときにたまに使う。

#+begin_src emacs-lisp
  (leaf web-mode
    :straight t
    :mode
    ("\\.html\\'" . web-mode)
    ("\\.rt\\'" . web-mode)
    :custom
    (web-mode-markup-indent-offset . 2)
    (web-mode-code-indent-offset . 2)
    :hook
    (web-mode-hook . my:web-mode-hook-angular-service)
    :preface
    (defun my:web-mode-hook-angular-service ()
      (when (and
             (string-match-p "\.component\.html\\'" (or buffer-file-name "")))
        (eglot-ensure)))
    )
#+end_src

*** JavaScript/TypeScript
ここも色々多いので、個別に記載していく。

**** add-node-modules-path
node_modules/.binをexec-pathに追加してくれる。

#+begin_src emacs-lisp
  (leaf add-node-modules-path :straight t)
#+end_src

**** js-mode
#+begin_src emacs-lisp
  (leaf js-mode
    :commands js-mode
    :custom
    (js-indent-level . 2)
    :preface
    (defun my:js-mode-hook ()
      )
    :hook
    (js-mode-hook . my:js-mode-hook)
    :mode
    ( "\\.[cm]?js\\'" . js-mode))
#+end_src

**** typescript-mode
#+begin_src emacs-lisp
  (leaf typescript-ts-mode
    :require t
    :if (version<= "29.1.0" emacs-version)
    :mode
    ("\\.m?ts\\'" . typescript-ts-mode)
    :hook
    (typescript-ts-mode-local-vars-hook . my:typescript-ts-mode-hook)
    :bind (:typescript-ts-mode-map
           ("M-j" . c-indent-new-comment-line))
    :custom
    (typescript-ts-mode-indent-offset . 2)
    :preface
    (defun my:typescript-ts-mode-hook ()
      (add-node-modules-path)
      (eglot-ensure)))
#+end_src

*** terraform-mode
#+begin_src emacs-lisp
  (leaf terraform-mode
    :straight t
    :mode ("\\.tf\\'" . terraform-mode))
#+end_src

*** plantuml-mode
#+begin_src emacs-lisp
  (leaf plantuml-mode
    :straight t
    :custom
    (plantuml-output-type . "png")
    (plantuml-options . "-charset UTF-8")
    (plantuml-default-exec-mode . 'jar)
    :config
    (let ((plantuml-jar-file (expand-file-name (locate-user-emacs-file "plantuml.jar"))))
      (setq plantuml-jar-path plantuml-jar-file)
      (unless (file-exists-p plantuml-jar-file)
        (call-process "curl" nil nil t "-L" "-o" plantuml-jar-file
                      "https://sourceforge.net/projects/plantuml/files/plantuml.jar/download"))))
#+end_src

*** groovy-mode
#+begin_src emacs-lisp
  (leaf groovy-mode
    :straight t
    :mode ("\\.groovy\\'" . groovy-mode))
#+end_src

*** protobuf-mode
#+begin_src emacs-lisp
  (leaf protobuf-mode
    :straight (protobuf-mode :type git :host github :repo "protocolbuffers/protobuf")
    :mode ("\\.proto\\'" . protobuf-mode)
    :hook
    (protobuf-mode-hook . my:protobuf-mode-hook)
    :config
    (defconst my:protobuf-style
      '((c-basic-offset . 2)
        (indent-tabs-mode . nil)))
    (defun my:protobuf-mode-hook ()
      (c-add-style "my-protobuf-style" my:protobuf-style)))
#+end_src

*** fish-mode
#+begin_src emacs-lisp
  (leaf fish-mode
    :straight t
    :mode ("\\.fish\\'" . fish-mode))
#+end_src

*** nushell-mode
nushell用のsytax hightling
#+begin_src emacs-lisp
  (leaf nushell-mode
    :straight (nushell-mode :type git :host github :repo "mrkkrp/nushell-mode")
    )
#+end_src
*** csv-mode
#+begin_src emacs-lisp
  (leaf csv-mode :straight t)
#+end_src

*** kotlin-mode
#+begin_src emacs-lisp
  (leaf kotlin-mode
    :straight t
    :hook
    (kotlin-mode-hook . eglot-ensure)
    )
#+end_src

*** text-mode

#+begin_src emacs-lisp
  (leaf text-mode
    :custom
    ;; emacs 30.1以降で追加されるオプションで、これがあるとcompleption-at-point-functionsが上書きされてしまうので、
    ;; 一旦切る。これはorg modeとかでも影響する。
    (text-mode-ispell-word-completion . nil))
#+end_src
** dashboard
#+begin_src emacs-lisp
  (leaf dashboard
    :straight t
    :diminish t
    :require t
    :custom
    (dashboard-startup-banner . 'ascii)
    (dashboard-set-navigator . t)
    (dashboard-set-init-info . t)
    (dashboard-items . '((recents . 15)
                         (projects . 5)
                         (agenda . 5)))
    (dashboard-banner-ascii . "
    ____
   |  _ \\  ___ _ __ _   _  ___ _ __ ___   __ _  ___ ___
   | | | |/ _ \\ '__| | | |/ _ \\ '_ ` _ \\ / _` |/ __/ __|
   | |_| |  __/ |  | |_| |  __/ | | | | | (_| | (__\\__ \\
   |____/ \\___|_|   \\__,_|\\___|_| |_| |_|\\__,_|\\___|___/
  ")
    :config
    (dashboard-setup-startup-hook))
#+end_src

** magit
#+begin_src emacs-lisp
  (leaf with-editor
    :straight t)

  (leaf compat
    :straight t
    :require t)

  (leaf magit
    :straight (magit :type git :host github :repo "magit/magit")
    :after (compat)
    :hook
    (git-commit-mode-hook . my:flyspell-enable)
    (git-commit-mode-hook . my:insert-commit-template-on-magit)
    (git-commit-mode-hook . my:use-insert-mode-on-magit)
    :preface
    (defun my:insert-commit-template-on-magit ()
      "Insert commit comment template after opened commit buffer on magit."
      (tempel-insert 'cc))

    (defun my:use-insert-mode-on-magit ()
      "Enable insert mode on magit buffer"
      (meow-insert)))
#+end_src

*** difftastic.el
https://github.com/pkryger/difftastic.el

difftasticという構造化diffツールのwrapper。

#+begin_src emacs-lisp
  (leaf difftastic
    :if (executable-find "difft")
    :straight t
    :bind (:magit-blame-read-only-mode-map
           ("D" . difftastic-magit-diff)
           ("S" . difftastic-magit-show))
    :config
    (eval-after-load 'magit-diff
      '(transient-append-suffix 'magit-diff '(-1 -1)
         [("D" "Difftastic diff (dwim)" difftastic-magit-diff)
          ("S" "Difftastic show" difftastic-magit-show)])))
#+end_src

** meow
#+begin_src emacs-lisp
  (leaf meow
    :straight t
    :require t
    :after consult
    :bind
    ((:meow-normal-state-keymap
      ("C-j" . (lambda ()
                 (interactive)
                 (if skk-mode (skk-j-mode-on))
                 (meow-append)))))
    :hook
    (meow-insert-exit-hook . my:use-latin-mode-when-skk)
    :custom
    (meow-use-clipboard . t)              ; use clipboard
    :preface
    (defun my:use-latin-mode-when-skk ()
      (if skk-mode (skk-latin-mode-on)))

    :config
    (defun my:meow-negative-find ()
      "A shortcut function to negative find (-f is default key sequence)"
      (interactive)
      (let ((current-prefix-arg -1))
        (call-interactively 'meow-find)))

    (defun my:meow-negative-till ()
      "A shortcut function to negative till (-t is default key sequence)"
      (interactive)
      (let ((current-prefix-arg -1))
        (call-interactively 'meow-till)))

    (defun meow-setup ()
      "setup meow in qwerty keyboard"
      (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
      
      (meow-leader-define-key
       ;; SPC j/k will run the original command in MOTION state.
       '("j" . "H-j")
       '("k" . "H-k")
       ;; Use SPC (0-9) for digit arguments.
       '("1" . meow-digit-argument)
       '("2" . meow-digit-argument)
       '("3" . meow-digit-argument)
       '("4" . meow-digit-argument)
       '("5" . meow-digit-argument)
       '("6" . meow-digit-argument)
       '("7" . meow-digit-argument)
       '("8" . meow-digit-argument)
       '("9" . meow-digit-argument)
       '("0" . meow-digit-argument)
       (cons "," my:global-user-mode-keymap)
       )
      (meow-normal-define-key
       '("0" . meow-expand-0)
       '("9" . meow-expand-9)
       '("8" . meow-expand-8)
       '("7" . meow-expand-7)
       '("6" . meow-expand-6)
       '("5" . meow-expand-5)
       '("4" . meow-expand-4)
       '("3" . meow-expand-3)
       '("2" . meow-expand-2)
       '("1" . meow-expand-1)
       '("-" . negative-argument)
       '(";" . meow-reverse)
       '("," . meow-inner-of-thing)
       '("." . meow-bounds-of-thing)
       '("[" . meow-beginning-of-thing)
       '("]" . meow-end-of-thing)
       '("a" . meow-append)
       '("A" . meow-open-below)
       '("b" . meow-back-word)
       '("B" . meow-back-symbol)
       '("c" . meow-change)
       '("d" . meow-delete)
       '("D" . meow-backward-delete)
       '("e" . meow-next-word)
       '("E" . meow-next-symbol)
       '("f" . meow-find)
       '("F" . my:meow-negative-find)
       '("g" . meow-cancel-selection)
       '("G" . meow-grab)
       '("h" . meow-left)
       '("H" . meow-left-expand)
       '("i" . meow-insert)
       '("I" . meow-open-above)
       '("j" . meow-next)
       '("J" . meow-next-expand)
       '("k" . meow-prev)
       '("K" . meow-prev-expand)
       '("l" . meow-right)
       '("L" . meow-right-expand)
       '("m" . meow-join)
       '("n" . meow-search)
       '("o" . meow-block)
       '("O" . meow-to-block)
       '("p" . meow-yank)
       '("P" . meow-paren-mode)
       '("q" . meow-quit)
       '("r" . meow-replace)
       '("R" . meow-swap-grab)
       '("s" . meow-kill)
       '("t" . meow-till)
       '("T" . my:meow-negative-till)
       '("u" . meow-undo)
       '("U" . vundo)
       '("v" . meow-visit)
       '("w" . meow-mark-word)
       '("W" . meow-mark-symbol)
       '("x" . meow-line)
       '("X" . meow-goto-line)
       '("y" . meow-save)
       '("Y" . meow-sync-grab)
       '("z" . meow-pop-selection)
       '("<" . backward-paragraph)
       '(">" . forward-paragraph)
       ;; keep bindings in evil at normal state
       (cons "C-w" my:ace-window-keymap)
       ;; use consult like vi/vim search
       '("/" . consult-line)
       ;; vi/vim-like paging. Original commands are already mapped in meow
       '("C-r" . meow-rectangle-mode)
       '("<escape>" . ignore)))

    (meow-setup)
    (meow-global-mode 1)

    (leaf *meow-paren
      :config
      ;; configurations for paren editing
      (setq meow-paren-keymap (make-keymap))
      (meow-define-state paren
        "meow state for interacting with smartparens"
        :lighter " [P]"
        :keymap meow-paren-keymap)

      ;; meow-define-state creates the variable
      (setq meow-cursor-type-paren 'hollow)

      (meow-define-keys 'paren
        '("<escape>" . meow-normal-mode)
        '("l" . sp-forward-sexp)
        '("h" . sp-backward-sexp)
        '("j" . sp-down-sexp)
        '("k" . sp-up-sexp)
        '("n" . sp-forward-slurp-sexp)
        '("b" . sp-forward-barf-sexp)
        '("v" . sp-backward-barf-sexp)
        '("c" . sp-backward-slurp-sexp)
        '("K" . sp-kill-sexp)
        '("u" . meow-undo)))

    (leaf *meow-arrow-thing
      :config
      (meow-thing-register 'arrow
                           '(pair ("<") (">"))
                           '(pair ("<") (">")))

      (setf (alist-get ?a meow-char-thing-table) 'arrow))

    (leaf *meow-rectangle
      :config
      (setq meow-rectangle-keymap (copy-keymap meow-normal-state-keymap))
      (meow-define-state rectangle
        "meow state for interacting with rectangle"
        :lighter " [R]"
        :keymap meow-rectangle-keymap)

      (meow-define-keys 'rectangle
        '("<escape>" . meow-normal-mode)
        ;; トグルすることにしておく
        '("C-r" . meow-normal-mode)
        '("m" . rectangle-mark-mode)
        '("s" . rectangle-kill)
        '("y" . copy-rectangle-as-kill))))
#+end_src
** minor-modes
*** cc-mode
#+begin_src emacs-lisp
  (leaf cc-mode
    :require t
    ;; .hはc++-modeで開く
    :mode ("\\.h$" . c++-mode)
    :preface
    (defun my:c-mode-hook ()
      (setq completion-mode t)
      ;; compile-windowの設定
      (setq compilation-buffer-name "*compilation*")
      (setq compilation-scroll-output t)
      (setq compilation-read-command t)
      (setq compilation-ask-about-save nil)
      (setq compilation-window-height 10)
      (setq compile-command "make")
      ;; cc-mode内で定義されるキーバインド
      (define-key c-mode-base-map (kbd "C-c C-c")   'comment-region)
      (define-key c-mode-base-map (kbd "C-c C") 'my-c++-cast)
      (define-key c-mode-base-map (kbd "C-c C-M-c") 'uncomment-region)
      (define-key c-mode-base-map (kbd "C-c e")      'c-macro-expand)
      (define-key c-mode-base-map (kbd "C-c c")      'my-compile)
      (define-key c-mode-base-map (kbd "C-c M-c")   'compilation-close)
      (define-key c-mode-base-map (kbd "C-c g")      'gdb)
      (define-key c-mode-base-map (kbd "C-c t")      'toggle-source)
      (define-key c-mode-base-map (kbd "C-c C-d") 'c-down-conditional)
      ;; cc-modeに入る時に自動的にgtags-modeにする
      (gtags-mode t))

    :hook
    (c-mode-common-hook . my:c-mode-hook))
#+end_src

*** ace-window
ウィンドウ間を1キーで移動できるようにするための拡張。

#+begin_src emacs-lisp
  (leaf ace-window :straight t
    :after posframe
    :preface
    ;; 複数箇所で利用するキーバインドを定義しておく
    (defvar my:ace-window-keymap (make-sparse-keymap))

    (dolist (keybind '(("C-w" . ace-window)
                       ("C-s" . split-window-vertically)
                       ("s" . split-window-vertically)
                       ("C-v" . split-window-horizontally)
                       ("v" . split-window-horizontally)
                       ("h" . windmove-left)
                       ("l" . windmove-right)
                       ("j" . windmove-down)
                       ("k" . windmove-up)
                       ("b" . balance-windows)
                       ("d" . delete-window)
                       ("o" . delete-other-windows)))
      (define-key my:ace-window-keymap (kbd (car keybind)) (cdr keybind)))

    :config
    (ace-window-posframe-mode t)
    ;; diredへの設定をここで設定している
    (define-key dired-mode-map (kbd "C-w") my:ace-window-keymap))
#+end_src
*** tempel
tempoに似たような構文を持つ、シンプルなテンプレートエンジン。corfuなどと効果的に組み合わせることができるようなキーバインドを提供している。

#+begin_src emacs-lisp
  (leaf tempel
    :straight (tempel :type git :host github :repo "minad/tempel" :branch "main")
    :commands tempel-complete
    :bind
    (tempel-map
     ("C-." . tempel-next)
     ("C-," . tempel-previous)))
#+end_src

*** symbol-overlay
symbolをハイライトするfaceを提供する。lspとかと見事に競合するので、lspを利用する場合はオフにするのを推奨。

#+begin_src emacs-lisp
  (leaf symbol-overlay
    :straight t
    :hook
    (prog-mode-hook . symbol-overlay-mode)
    :custom-face
    (symbol-overlay-default-face . '((t (:inherit highlight :underline t)))))
#+end_src

*** pulsar
よりシンプルなbeacon
https://protesilaos.com/emacs/pulsar

#+begin_src emacs-lisp
  (leaf pulsar
    :straight t
    :custom
    (pulsar-face . 'pulsar-magenta)
    :config
    (pulsar-global-mode +1))
#+end_src
*** imenu-list
#+begin_src emacs-lisp
  (leaf imenu-list
    :straight t
    :custom
    (imenu-list-size . 0.25)
    (imenu-list-auto-resize . nil)
    (imenu-list-focus-after-activation . t))
#+end_src

*** whick-key
#+begin_src emacs-lisp
  (leaf which-key
    :straight t
    :custom
    (which-key-max-description-length . 40)
    (which-key-use-C-h-commands . t)
    :hook
    (emacs-startup-hook . which-key-mode))
#+end_src

*** smartparens
#+begin_src emacs-lisp
  (leaf smartparens
    :straight t
    :commands sp-local-pair smartparens-global-mode
    ;; ほぼEmacs Lispのみで使うので、Emacs Lispのみで有効にする
    :config
    (sp-local-pair 'emacs-lisp-mode "'" nil :actions nil)
    (sp-local-pair 'emacs-lisp-mode "`" nil :actions nil)
    (sp-local-pair 'lisp-mode "'" nil :actions nil)
    (sp-local-pair 'lisp-mode "`" nil :actions nil)
    (sp-local-pair 'tuareg-mode "`" nil :actions nil)
    (sp-local-pair 'tuareg-mode "'" nil :actions nil)
    (sp-local-pair 'rust-mode "'" nil :actions nil))
#+end_src

*** diff-hl
git-gutter系統をよりシンプルにしたもの。

#+begin_src emacs-lisp
  (leaf diff-hl
    :straight t
    :custom
    ;; fringeに対してborderを表示しない
    (diff-hl-draw-borders . nil)
    :config
    (global-diff-hl-mode))
#+end_src
*** flymake
#+begin_src emacs-lisp
  (leaf flymake
    :ensure t
    :bind
    (("<f2>" . flymake-goto-next-error)
     ("S-<f2>" . flymake-goto-prev-error)))
#+end_src
*** flycheck
#+begin_src emacs-lisp
  (leaf flycheck
    :straight t
    :require t
    :config
    (advice-add 'flycheck-eslint-config-exists-p :override (lambda () t))
    :hydra
    (hydra-flycheck nil
                    "
        Navigate Error^^    Miscellaneous
        ---------------------------------------------------
        [_k_] Prev          [_c_] Clear
        [_j_] Next
        [_f_] First Error   [_q_] Quit
        [_l_] Lask Error
        "
                    ("j" flycheck-next-error)
                    ("k" flycheck-previous-error)
                    ("f" flycheck-first-error)
                    ("l" (progn (goto-char (point-max)) (fiycheck-previous-error)))
                    ("c" flycheck-clear)
                    ("q" nil)))
#+end_src

*** posframe
#+begin_src emacs-lisp
  (leaf posframe
    :straight t
    :when (and window-system my:use-posframe)
    :config

    (when (eq (window-system) 'x)
      (setq posframe-gtk-resize-child-frames 'resize-mode))

    (leaf mozc-posframe
      :straight (mozc-posframe :type git :host github :repo "derui/mozc-posframe")
      :if (and my:use-mozc-el my:mozc-helper-locate)
      :config
      (mozc-posframe-register))

    (leaf flycheck-posframe
      :after flycheck
      :straight t
      ;; :hook (flycheck-mode-hook . flycheck-posframe-mode)
      )
    )
#+end_src

*** eldoc-box
eldocをchildframeで表示するようにしてくれる。

#+begin_src emacs-lisp
  (leaf eldoc-box
    :straight t
    :custom
    ;; 複数行の場合だけ表示するようにする
    (eldoc-box-only-multi-line . t))
#+end_src
*** vundo
昔使ってたundo-treeの別バージョン、みたいなもの。

https://github.com/casouri/vundo

#+begin_src emacs-lisp
  (leaf vundo
    :straight t
    :hook
    (vundo-mode-hook . my:vundo-mode-hook)
    :preface
    (defun my:vundo-mode-hook ()
      ;; 色々邪魔になるので、meow-mode を無効化
      (meow-mode -1)
      )
    )
#+end_src
*** eglot
Emacs29から標準添付になったので、これを利用してみる。

#+begin_src emacs-lisp
  (leaf eglot
    :ensure t
    :bind
    (:eglot-mode-map
     ("C-c r" . eglot-rename)
     ;; intellijの方と挙動を揃える
     ("C-<return>" . eglot-code-actions)
     ("M-m" . eldoc-box-help-at-point))
    :custom
    ;; 補完候補を表示するときとかにあまりにでかすぎてスローダウンしているので0にしておく
    (eglot-events-buffer-size . 0)
    :config

    (add-to-list 'eglot-server-programs '(((ocaml-ts-mode :language-id)) . ("ocamllsp")))
    
    ;; eglotでもhotfuzzを利用するようにする
    (add-to-list 'completion-category-overrides
                 '(eglot (styles hotfuzz basic))))
#+end_src
*** eglot-booster
    eglotのcommunicateにおいて、Rust製のprogramを利用することで、JSONのParseに伴う諸々の性能問題を解消しようとするpackage。

    #+begin_src emacs-lisp
      (leaf eglot-booster
        :straight (eglot-booster :type git :host github :repo "jdtsmith/eglot-booster")
        :after eglot
        :config
        (eglot-booster-mode))
    #+end_src
*** aggressive-indent
#+begin_src emacs-lisp
  (leaf aggressive-indent
    :straight t
    :commands aggressive-indent-mode
    :hook
    (lisp-mode-hook . aggressive-indent-mode)
    (emacs-lisp-mode-hook . aggressive-indent-mode))
#+end_src

*** copilot.el
GitHub Copilotを利用するための設定。

#+begin_src emacs-lisp
  (leaf copilot
    :straight (copilot :type git :host github :repo "zerolfx/copilot.el" :files ("dist" "*.el"))
    :bind
    (:copilot-mode-map
     ;; TABにはすでにcompletion-at-pointが入っている状態なので、一旦別に割り当てておく
     ("<tab>" . my:indent-for-tab-command-dwim)
     ("TAB" . my:indent-for-tab-command-dwim))
    :hook
    ;; プログラミング関連で有効にしておく
    (prog-mode-hook . copilot-mode)
    ;; タイミングとしてはここでやらないとダメみたなのでここで実行しておく
    (emacs-startup-hook . my:recreate-copilot-balancer-debug-buffer)
    :preface
    (defun my:not-completion-in-region-mode-p ()
      "Predicate to check if `completion-in-region-mode' is enabled."
      (null completion-in-region-mode))
    :custom
    ;; 常時やってもあまり意味がないので、タイピングが続いている間はやらないようにする
    (copilot-idle-delay . 0.5)
    ;; ファイルを開く度にワーニングになるのだが、実害が基本的にないので、ワーニング自体を無視しておく
    (copilot-indent-offset-warning-disable . t)
    :config
    ;; evilを使っていないので、evil関連のものは抜いておき、そのかわりにmeowのものを入れておく
    (setq copilot-enable-predicates
          (-remove (lambda (x) (eq x 'evil-insert-state-p))
                   copilot-enable-predicates))

    ;; corfuなりが起動している場合は、そもそも有効にしないようにする
    (add-to-list 'copilot-enable-predicates 'my:not-completion-in-region-mode-p)
    (add-to-list 'copilot-enable-predicates 'meow-insert-mode-p)

    (defun my:indent-for-tab-command-dwim ()
      "必要があればindent-for-tab-commandを呼び出す"
      (interactive)
      (or (copilot-accept-completion)
          (indent-for-tab-command)))
    
    ;; tuaregはocamlにしてもらわないと困る
    (add-to-list 'copilot-major-mode-alist '("tuareg" . "ocaml"))

    (defun my:recreate-copilot-balancer-debug-buffer ()
      "copilot-balancerのデバッグ用バッファを再作成する"
      ;; なんでかわからないけどこのバッファが削除されてて非常に厄介なので、ここで再度作成しておく
      (setq copilot-balancer-debug-buffer (get-buffer-create " *copilot-balancer*"))))
#+end_src

*** goggles
volatile-highlightsの代替。

https://github.com/minad/goggles

#+begin_src emacs-lisp
  (leaf goggles
    :straight t
    :hook
    (prog-mode . goggles-mode)
    (text-mode . goggles-mode)
    :config
    (setq-default goggles-pulse t))
#+end_src
*** lin
    hl-line-modeの見た目を変えるためのpackage。

    https://protesilaos.com/emacs/lin

    #+begin_src emacs-lisp
      (leaf lin
        :straight t
        :config
        (lin-global-mode 1))
    #+end_src
** utility packages
*** nerd-icons
https://github.com/rainstormstudio/nerd-icons.el#installing-fonts

all-the-iconsの代替とのこと。all-the-iconsはターミナルでは利用できないらしいが、これはnerd-fontsにだけ依存しているので利用できるらしい。

#+begin_src emacs-lisp
  (leaf nerd-icons
    :require t
    :straight (nerd-icons :type git :host github :repo "rainstormstudio/nerd-icons.el")
    )
#+end_src

*** kind-icon
marginalia、consultとかと協調して動作可能な、ミニマルなアイコンライブラリ。

#+begin_src emacs-lisp
  (leaf kind-icon
    :straight (kind-icon :type git :host github :repo "jdtsmith/kind-icon")
    :require t
    :after corfu
    :custom
    (kind-icon-default-face . 'corfu-default) ; to compute blended backgrounds correctly
    :config
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+end_src

*** notifications
#+begin_src emacs-lisp
  (leaf notifications :require t)
#+end_src

*** s
#+begin_src emacs-lisp
  (leaf s
    :straight t
    :commands s-join)
#+end_src

*** exec-path-from-shell
#+begin_src emacs-lisp
  (leaf exec-path-from-shell
    :straight t
    :config
    (exec-path-from-shell-initialize)
    (let ((envs '("GOROOT" "GOPATH" "PATH")))
      (exec-path-from-shell-copy-envs envs)))
#+end_src

*** rg.el
ripgrep.elではなく、 rg.elを利用する。特定のファイルパターンにだけ実行したりしたい。

#+begin_src emacs-lisp
  (leaf rg
    :straight t
    :config
    (rg-enable-default-bindings))
#+end_src

*** langtool
flyspellとはまた別で、英語自体の構文とかそういうのをチェックしてくれるLangtoolを入れる。

#+begin_src emacs-lisp
  (leaf langtool
    :straight t
    :commands langtool-details-error-message
    :custom
    (langtool-language-tool-jar . my:langtool-cli-path)
    (langtool-default-language . "en-US")
    (langtool-java-user-arguments . '("-Dfile.encoding=UTF-8")))
#+end_src
**** langtoolのインストール
#+begin_src emacs-lisp
  (leaf *langtool
    :if (eq window-system 'x)
    :config
    (unless (file-exists-p my:langtool-cli-path)
      (make-directory (expand-file-name "~/.emacs.d/share") t)
      (let ((langtool-url (format "https://languagetool.org/download/LanguageTool-%s.zip" my:langtool-version))
            (output "/tmp/LanguageTool.zip"))

        (call-process "curl" nil nil t "-L" "-o" output langtool-url)
        (call-process "unzip" nil nil t "-d" (expand-file-name "~/.emacs.d/share") output)
        (rename-file (format "~/.emacs.d/share/LanguageTool-%s/languagetool-commandline.jar" my:langtool-version)
                     my:langtool-cli-path t))))
#+end_src

*** treemacs
#+begin_src emacs-lisp
  (leaf treemacs
    :straight t
    :custom
    (treemacs-is-never-other-window . nil)
    (treemacs-read-string-input . 'from-minibuffer)
    (treemacs-file-event-delay . 1000)
    :hook
    (treemacs-mode-hook . (lambda ()
                            (when (version<= "27.0.0" emacs-version)
                              (display-line-numbers-mode -1))))
    :config
    (leaf treemacs-icons-dired :straight t :require t
      :config
      (treemacs-icons-dired-mode)))
#+end_src

*** mozc
#+begin_src emacs-lisp
  (leaf mozc
    :straight t
    :if (and my:use-mozc-el my:mozc-helper-locate)
    :custom
    (mozc-keymap-kana . mozc-keymap-kana-101us)
    (mozc-candidate-style . 'posframe)
    (mozc-helper-program-name . my:mozc-helper-locate))
#+end_src

*** projectile
#+begin_src emacs-lisp
  (leaf projectile
    :straight t
    :commands projectile-register-project-type
    :hook
    (emacs-startup-hook . projectile-mode)
    :bind
    (:projectile-command-map
     ("s" . my:projectile-search-dwim))
    :custom
    (projectile-enable-idle-timer . nil)
    (projectile-enable-caching . t)
    (projectile-completion-system . 'auto)
    :preface
    (defun my:projectile-search-dwim (search-term)
      "Merge version to search document via grep/ag/rg.
        Use fast alternative if it exists, fallback grep if no alternatives in system.
        "
      (interactive (list (projectile--read-search-string-with-default
                          "Dwim search for")))
      (cond
       ((executable-find "rg") (projectile-ripgrep search-term))
       ((executable-find "ag") (projectile-ag search-term))
       (t (projectile-grep search-term))))

    :config
    (projectile-register-project-type
     'yarn
     '("package.json")
     :compile "yarn build"
     :test "yarn test"
     :run "yarn start"
     :test-suffix ".test"))
#+end_src

*** treesit
Emacs 29からはtreesitという形でtree-sitterが組み込みで利用できるようになっている。ただしこれ、現状だと  ~*-ts-mode~ という標準モードでしか利用されていないらしく、かつそっちを利用しようとするとかなり大変なことになったりが多い。
treesit自体は魅力的なのだが、font-lockの仕組みそのものが別物ということのようなので、別物として作成しないといけない雰囲気が大分する。

#+begin_src emacs-lisp
  (leaf treesit
    :if (version<= "29.0.0" emacs-version)
    :require t
    :custom
    ;; font lockで最大のレベルを利用しておく
    (treesit-font-lock-level . 4)
    :config

    (leaf treesit-auto
      :straight t
      :require t
      :custom
      ;; 対象のパーサがすでにあったら自動的にインストールしてくれる
      (treesit-auto-install . t)
      :config
      (global-treesit-auto-mode)))
#+end_src

*** perspective
作業領域を保存したりなんだりできるもの。

#+begin_src emacs-lisp
  (defvar my:perspectives '("org" "code" "misc"))

  (leaf perspective
    :straight t
    :hook
    ;; (emacs-startup-hook . my:persp-init-0)
    (kill-emacs-hook . persp-state-save)
    :custom
    (persp-state-default-file . "~/.emacs.d/persp-state-file")
    (persp-modestring-short . t)
    :config
    (defun my:persp-init-0 ()
      (persp-mode +1)
      (dolist (p my:perspectives)
        (persp-switch p))
      (persp-switch (car my:perspectives))
      (persp-kill "main")))
#+end_src

*** diredfl
diredにfont-lockを適用していい感じにしてくれる。

#+begin_src emacs-lisp
  (leaf diredfl :straight t
    :config
    (diredfl-global-mode))
#+end_src

*** simple-pomodoro
自作のpomodoro timer用パッケージ。

#+begin_src emacs-lisp
  (leaf alert
    :straight t
    :require t
    :config
    (setq alert-default-style (cond
                               ((string-match ".*darwin.*" (or system-configuration "")) 'osx-notifier)
                               ((string-match ".*linux-gnu.*" (or system-configuration "")) 'notifications)
                               (t 'message))))

  (leaf simple-pomodoro
    :straight (simple-pomodoro :type git :host github :repo "derui/simple-pomodoro" :files (:defaults "misc/*"))
    :require t
    :hook
    (org-clock-in-hook . simple-pomodoro-start)
    (org-clock-out-hook . simple-pomodoro-stop)
    :custom
    (simple-pomodoro-auto-short-break . t)
    :config
    (leaf simple-pomodoro-notification
      :require t
      :custom
      (simple-pomodoro-notification-icon . `((default . ,(expand-file-name "images/001-tomato.png" user-emacs-directory))))
      :config
      (setq simple-pomodoro-notification-function #'simple-pomodoro-notification))

    (leaf simple-pomodoro-mode-line
      :require t
      :config
      (setq simple-pomodoro-tick-function (lambda (&rest args)
                                            (simple-pomodoro-mode-line-update-text)
                                            (force-mode-line-update)))))
#+end_src

*** rainbow-delimiters
定番のパッケージ。括弧を階層毎に色付けしてくれる。

#+begin_src emacs-lisp
  (leaf rainbow-delimiters
    :straight t
    :hook
    (prog-mode-hook . rainbow-delimiters-mode))
#+end_src
*** perfect-margin
自動的にcenterになるようにmarginを調整する。左右に分割している場合は動作しない。

https://github.com/mpwang/perfect-margin

#+begin_src emacs-lisp
  (leaf perfect-margin
    :straight t
    :custom
    (perfect-margin-ignore-filters . nil)
    :config
    (perfect-margin-mode 1))
#+end_src
*** spacious-padding
modusの作者が開発している、window/frameの間隔を調整するためのpackage。

https://github.com/protesilaos/spacious-padding?tab=readme-ov-file

#+begin_src emacs-lisp
  (leaf spacious-padding
    :straight t
    :custom
    (spacious-padding-widths . '(
                                 :internal-border-width 15
                                 :header-line-width 4
                                 ;; 設定しているmode lineとの相性が悪いので、0にしている
                                 :mode-line-width 0
                                 :tab-width 4
                                 :right-divider-width 30
                                 :scroll-bar-width 8))
    :config
    (spacious-padding-mode 1))
#+end_src
*** breadcrumb
パンくずリスト。

https://github.com/joaotavora/breadcrumb

#+begin_src emacs-lisp
  (leaf breadcrumb
    :straight t
    :hook
    (prog-mode-hook . breadcrumb-local-mode))
#+end_src
** モードライン関連
主にモードラインに対するパッケージをまとめている。

*** hide-mode-line
実行したバッファのモードラインを消去する。

#+begin_src emacs-lisp
  (leaf hide-mode-line
    :straight t
    :hook
    (imenu-list-major-mode-hook . hide-mode-line-mode)
    (treemacs-mode-hook . hide-mode-line-mode))
#+end_src

*** moody
magitのメインコミッターが作成しているパッケージ。基本的には見た目を変えるためだけのものであり、それ以外については自前で色々やる必要がある。

#+begin_src emacs-lisp
  (leaf moody
    :straight t
    :require t
    :config
    (setq x-underline-at-descent-line t))
#+end_src

*** custom mode line definition
moodyを前提にしつつ、doom-modelineを利用しないので、自前で色々設定する

#+begin_src emacs-lisp
  (leaf *my-mode-line
    :after (simple-pomodoro modus-themes)
    :config
    (defgroup my:mode-line nil
      "Custom mode line."
      :group 'my)

    (defface my:buffer-position-active-face nil
      "Face for active buffer position indicator."
      :group 'my:mode-line)

    (defface my:mode-line:vc-icon-face nil
      "Face for vcs icon"
      :group 'my:mode-line)

    (defvar my:vc-status-text ""
      "Variable to store vc status text.")

    (setq my:mode-line-read-only-icon "  "
          my:mode-line-writable-icon "  "
          my:mode-line-modified-icon "  ")

    (defun my:mode-line-status ()
      "Return status icon for mode line status. This function uses nerd-icon package to get status icon."
      (let ((read-only (and buffer-file-name buffer-read-only))
            (modified (and buffer-file-name (buffer-modified-p))))

        (cond 
         (modified my:mode-line-modified-icon)
         (read-only my:mode-line-read-only-icon)
         (t my:mode-line-writable-icon))))

    (defun my:update-mode-line-vc-text ()
      "Update vcs text is used in mode-line"
      (setq my:vc-status-text
            (cond 
             ((and vc-mode buffer-file-name)
              (let* ((backend (vc-backend buffer-file-name))
                     (branch-name (if vc-display-status
                                      ;; 5 is skipped Gitx
                                      (substring vc-mode 5)
                                    ""))
                     (state (cl-case (vc-state buffer-file-name backend)
                              (added "  ")
                              (needs-merge "  ")
                              (needs-update "  ")
                              (removed "  ")
                              (t "  "))))
                (concat (propertize state 'face 'my:mode-line:vc-icon-face) branch-name)))
             (t ""))))
    ;; should update status text after refresh state
    (advice-add #'vc-refresh-state :after #'my:update-mode-line-vc-text)

    (defun my:mode-line-vc-state ()
      "Retrun status of current buffer."
      (when-let ((vc-status (my:update-mode-line-vc-text)))
        vc-status))

    (defun my:mode-line-buffer-position-percentage ()
      "Return current buffer position in percentage."
      (let ((pmax (point-max))
            (current (point)))
        (format "%d%%%%" (/ (* 100 current) pmax))))

    ;; definitions of mode-line elements
    (setq my:mode-line-element-buffer-status '(:eval (concat (my:mode-line-status)
                                                             (meow-indicator)))
          my:mode-line-element-skk-indicator '(:eval (if (string= "" (or skk-modeline-input-mode ""))
                                                         " NO "
                                                       (concat " " skk-modeline-input-mode " ")))
          my:mode-line-element-major-mode '(:eval (concat " " (let ((name mode-name))
                                                                (cond
                                                                 ((consp name) (car name))
                                                                 (t name)))
                                                          " "))
          my:mode-line-element-vc-mode '(:eval (moody-ribbon (if vc-mode (my:mode-line-vc-state)
                                                               "No VCS")))
          my:mode-line-element-buffer-position '(:eval (moody-ribbon
                                                        (propertize
                                                         (my:mode-line-buffer-position-percentage)
                                                         'face 'my:buffer-position-active-face)
                                                        7))
          my:mode-line-element-pomodoro '(:eval (if (featurep 'simple-pomodoro)
                                                    (simple-pomodoro-mode-line-text)
                                                  ""
                                                  )))

    (put 'my:mode-line-element-buffer-status 'risky-local-variable t)
    (put 'my:mode-line-element-skk-indicator 'risky-local-variable t)
    (put 'my:mode-line-element-major-mode 'risky-local-variable t)
    (put 'my:mode-line-element-vc-mode 'risky-local-variable t)
    (put 'my:mode-line-element-buffer-position 'risky-local-variable t)
    (put 'my:mode-line-element-pomodoro 'risky-local-variable t)

    ;; define default mode line format
    (defun my:init-mode-line ()
      "Initialize mode line"
      (set-face-attribute 'my:buffer-position-active-face
                          nil
                          :inherit 'mode-line
                          :foreground (modus-themes-get-color-value 'red-warmer))

      (set-face-attribute 'my:mode-line:vc-icon-face
                          nil
                          :inherit 'mode-line
                          :foreground (modus-themes-get-color-value 'fg-alt))

      ;; replace mode line elements via moody
      (moody-replace-mode-line-front-space)
      (moody-replace-mode-line-buffer-identification)

      (setq-default mode-line-format
                    '("%e"
                      moody-mode-line-front-space
                      my:mode-line-element-buffer-status
                      moody-mode-line-buffer-identification
                      mode-line-format-right-align
                      my:mode-line-element-pomodoro
                      my:mode-line-element-vc-mode
                      my:mode-line-element-skk-indicator
                      my:mode-line-element-buffer-position
                      my:mode-line-element-major-mode)))

    (add-hook 'find-file-hook #'my:update-mode-line-vc-text)
    (add-hook 'after-save-hook #'my:update-mode-line-vc-text)
    (my:init-mode-line))
#+end_src
** completion UI関連
*** consult
swiper/counselの置き換え。

#+begin_src emacs-lisp
  (leaf consult
    :straight t
    :require t
    :bind
    ;; replace isearch
    ("C-s" . consult-line)
    :config
    (defun my:consult-search-dwim (&optional prefix)
      "Merge version to search document via grep/rg.
       Use fast alternative if it exists, fallback grep if no alternatives in system.
      "
      (interactive "P")
      (cond
       ((executable-find "rg") (consult-ripgrep prefix))
       (t (consult-grep prefix))))

    ;; recent fileでpreviewする場合は明示的に実行する
    (consult-customize consult-recent-file
                       :preview-key "M-.")
    )
#+end_src

*** embark
Contextに応じたアクションを実行できる、というようなもの。embark-actを実行して、そこに対して特定のキーにバインドされているアクションを実行する形。大体はembark-exportでやればよい。

- B :: ~embark-become~
- S :: ~embark-collect-snapshot~
- L :: ~embark-collect-live~
- E :: ~embark-export~


というのがデフォルトのバインディングになっている。

#+begin_src emacs-lisp
  (leaf embark
    :straight t
    :bind
    (("C-S-a" . embark-act)
     ("<f1> B" . embark-bindings)))

  (leaf embark-consult
    :straight t
    :after (embark consult)
    :hook
    (embark-collect-mode-hook . embark-consult-preview-minor-mode))
#+end_src

**** embarkのアクション
やりたいことベースでメモる。

- consultで検索した結果をoccurして一括編集
  - ~consult-line~ (C-s) → ~embark-export~
    - C-S-aしてからすぐ ~E~
- consultでファイルから検索した結果を一括編集
  - ~consult-ripgrep~ (, s) → ~embark-export~
    - C-S-aしてからすぐ ~E~


大体はexportするとwgrep/occur-editとかができるようになる、と覚えればよし。

*** marginalia
minibufferの表示に対して注釈？を追加できるパッケージ。consult/embarkそれぞれのパッケージで利用が強く推奨されているので。

注釈というか、metaという情報らしい。

#+begin_src emacs-lisp
  (leaf marginalia
    :straight t
    ;; Either bind `marginalia-cycle` globally or only in the minibuffer
    :bind
    (:minibuffer-local-map
     ("M-A" . marginalia-cycle))
    :commands (marginalia-mode)
    :global-minor-mode t
    :config
    (add-to-list 'marginalia-prompt-categories
                 '("\\<File\\>" . file)))
#+end_src

*** vertico
https://github.com/minad/vertico

垂直補完UIを提供することのみを目的としたUIライブラリ。

#+begin_src emacs-lisp
  (leaf vertico
    :straight (vertico :type git :host github :repo "minad/vertico")
    :custom
    ;; 最大20件まで表示するように
    (vertico-count . 20)
    :config
    (vertico-mode)

    (leaf vertico-directory
      :after vertico
      :require t
      ;; More convenient directory navigation commands
      :bind (:vertico-map
             ("RET" . vertico-directory-enter)
             ("DEL" . vertico-directory-delete-char)
             ("M-DEL" . vertico-directory-delete-word))))
#+end_src

*** orderless
completionのstyleを変更するパッケージ。基本的には空白区切りでのfilteringを提供する。

#+begin_src emacs-lisp
  (leaf orderless
    :straight t
    :require t
    :commands orderless-filter)

  (leaf *orderless-migemo-config
    :after (migemo orderless)
    :config
    ;; from https://nyoho.jp/diary/?date=20210615
    (defun my:orderless-migemo (component)
      (let ((pattern (migemo-get-pattern component)))
        (condition-case nil
            (progn (string-match-p pattern "") pattern)
          (invalid-regexp nil))))

    (orderless-define-completion-style orderless-default-style
      (orderless-matching-styles '(orderless-literal
                                   orderless-regexp)))

    (orderless-define-completion-style orderless-migemo-style
      (orderless-matching-styles '(orderless-literal
                                   orderless-regexp
                                   my:orderless-migemo)))

    (setq completion-category-overrides
          '((command (styles orderless-default-style))
            ;; ファイルの場合には、pathの部分matchをするように
            (file (styles orderless-migemo-style))
            (org-roam-node (styles . (partial-completion orderless-migemo-style)))
            (buffer (styles orderless-migemo-style))
            (symbol (styles orderless-default-style))
            (consult-location (styles orderless-migemo-style)) ; category `consult-location' は `consult-line' などに使われる
            (consult-multi (styles orderless-migemo-style)) ; category `consult-multi' は `consult-buffer' などに使われる
            (unicode-name (styles orderless-migemo-style))
            (variable (styles orderless-default-style)))))
#+end_src

*** hotfuzz
built-inのflexに似た結果を生成するが、より高速かつ、単語間の切れめなどがよりわかりやすいようになっている。

#+begin_src emacs-lisp
  (leaf hotfuzz
    :straight t
    :config
    (push 'hotfuzz completion-styles)
    (setq
     ;; For example, project-find-file uses 'project-files which uses
     ;; substring completion by default. Set to nil to make sure it's using
     ;; flx.
     completion-category-defaults nil
     completion-category-overrides nil))
#+end_src
*** corfu
minimalなregion completion。child frameを利用しているのと、あくまでシンプルなUIのみを提供しているため、軽量かつ高速。

#+begin_src emacs-lisp
  (leaf corfu
    :straight (corfu :type git :host github :repo "minad/corfu" :branch "main")
    :custom
    (corfu-cycle . t)                ;; Enable cycling for `corfu-next/previous'
    (corfu-auto . t)                 ;; Enable auto completion
    (corfu-auto-delay . 0.1)                 ;; 即時表示を試してみる
    (corfu-count . 15)                        ;; show more candidates
    (corfu-auto-prefix . 2)
    (corfu-max-width . 300)               ;; max width of corfu completion UI
    (corfu-on-exact-match . nil)          ; 単独で厳密マッチしたものがあった場合の挙動。一旦何もしない。
    :hook
    (emacs-startup-hook . global-corfu-mode)
    :init
    (defvar-keymap my:corfu-auto-map
      :doc "Keymap used when popup is shown automatically."
      "C-g" #'corfu-quit)
    (defvar my:corfu-in-auto-complete nil)
    
    :config
    ;; corfuでauto表示はするものの、TABを押すまで選択しないようにする設定
    ;; https://misohena.jp/blog/2024-02-15-separate-notification-and-selection-with-corfu-auto.html
    
    (defun my:corfu--auto-complete-deferred:around (oldfun &rest args)
      ;; 自動補完を試みるときに呼び出される
      (let ((my:corfu-in-auto-complete t))
        ;; 元の関数を呼び出す
        ;; 補完候補があるなら続けてsetup等が呼ばれる
        (apply oldfun args)))

    (advice-add 'corfu--auto-complete-deferred :around #'my:corfu--auto-complete-deferred:around)

    (defun my:corfu--setup:around (oldfun &rest args)
      (if my:corfu-in-auto-complete
          ;; 自動補完の時
          (progn
            (setf
             ;; 子フレームを半透明にする
             (alist-get 'alpha-background corfu--frame-parameters) 80
             ;; 最初の候補を選ばない
             corfu-preselect 'prompt)
            ;; キー割り当てを極力無くす
            (let ((corfu-map my:corfu-auto-map))
              (apply oldfun args)))
        ;; 手動補完の時
        (setf
         ;; 子フレームを完全不透明にする
         (alist-get 'alpha-background corfu--frame-parameters) 100
         ;; 最初の候補を選ぶ
         corfu-preselect 'first)
        (apply oldfun args)))
    
    (advice-add 'corfu--setup :around #'my:corfu--setup:around)

    (leaf corfu-popupinfo
      :require t
      :hook
      (corfu-mode-hook . corfu-popupinfo-mode)))
#+end_src
*** cape
capf = completion-at-point-functionを極限までシンプルに拡張するための処理。corfuなどとは独立していて、あくまでcapfを拡張するだけに留まっている。

#+begin_src emacs-lisp
  (leaf cape
    :straight t
    :require t
    :hook
    (eglot-managed-mode-hook . my:eglot-capf)
    :config
    (defun my:eglot-capf ()
      "set capf for eglot"
      (setq-local completion-at-point-functions
                  (list (cape-capf-case-fold
                         (cape-capf-super
                          #'eglot-completion-at-point
                          #'tempel-complete
                          #'cape-file)))))

    ;; Add `completion-at-point-functions', used by `completion-at-point'.
    (add-to-list 'completion-at-point-functions #'tempel-complete)
    (add-to-list 'completion-at-point-functions #'cape-file)
    (add-to-list 'completion-at-point-functions #'cape-keyword))
#+end_src
** migemo関連

*** migemo
#+begin_src emacs-lisp
  (leaf migemo
    :straight t
    :require t
    :if (and my:migemo-command (executable-find my:migemo-command))
    :commands migemo-init
    :hook (emacs-startup-hook . migemo-init)
    :custom
    (migemo-command . my:migemo-command)
    (migemo-options . '("-q" "--emacs"))
    (migemo-dictionary . my:migemo-dictionary)
    (migemo-user-dictionary . nil)
    (migemo-regex-dictionary . nil)
    (migemo-coding-system . 'utf-8-unix)
    ;; 遅いのを防ぐためにキャッシュする。
    (migemo-use-pattern-alist . t)
    (migemo-use-frequent-pattern-alist . t)
    (migemo-pattern-alist-length . 1024)
    :config
    (migemo-init))
#+end_src

** テーマ

*** modus-themes
#+begin_src emacs-lisp
  (leaf modus-themes
    :straight (modus-themes :type git :host github :repo "protesilaos/modus-themes")
    :init
    (setq modus-themes-slanted-constructs t
          modus-themes-bold-constructs t
          modus-themes-mixed-fonts nil
          modus-themes-variable-pitch-ui nil)
    :config
    ;; load light theme
    (load-theme 'modus-vivendi-tinted)
    (let ((line (face-attribute 'mode-line :underline)))
      (set-face-attribute 'mode-line          nil :overline   line)
      (set-face-attribute 'mode-line-inactive nil :overline   line)
      (set-face-attribute 'mode-line-inactive nil :underline  line)
      (set-face-attribute 'mode-line          nil :box        nil)
      (set-face-attribute 'mode-line-inactive nil :box        nil)))
#+end_src

** SKK

*** ddskk
#+begin_src emacs-lisp
  (leaf ddskk
    :straight t
    ;; ddskkは (provide 'skk) されているので、skkでrequireするようにする
    :require skk
    :bind (("<Hangul>" . my:enable-japanese-input)
           ("<henkan>" . my:enable-japanese-input)
           ("<f13>" . my:enable-japanese-input)
           ("<Hangul_Hanja>" . my:disable-japanese-input)
           ("<muhenkan>" . my:disable-japanese-input)
           ("C-<f13>" . my:disable-japanese-input))
    :preface
    (defun my:enable-japanese-input ()
      (interactive)
      (set-input-method my:input-method))

    (defun my:disable-japanese-input ()
      (interactive)
      (set-input-method nil))
    :init
    (setq default-input-method my:input-method
          skk-init-file (expand-file-name "init-ddskk.el" user-emacs-directory))

    (defun my:disable-skk-modeline-force-change (old-func &rest r)
      "そのままだとmode lineのフォーマットが勝手に変わってしまって非常に面倒なことになるため、
  起動する瞬間だけ該当の処理をスキップする。
  "
      (setq skk-status-indicator 'minor-mode)
      (apply old-func r)
      (setq skk-status-indicator 'left))

    (advice-add #'skk-mode-invoke :around  #'my:disable-skk-modeline-force-change))
#+end_src

*** ddskk-posframe
#+begin_src emacs-lisp
  (leaf ddskk-posframe
    :straight t
    :if my:use-posframe
    :global-minor-mode t)
#+end_src

*** yaskkserv2の設定
#+begin_src emacs-lisp
  (leaf f :straight t)
  (leaf *skk-server
    :after f
    :if my:use-skkserver
    :init
    (let ((server-program (expand-file-name "yaskkserv2"  my:user-local-exec-path))
          (dictionary-program (expand-file-name "yaskkserv2_make_dictionary" my:user-local-exec-path)))
      (cond ((and my:build-skkserver
                  (executable-find "cargo")
                  (not (executable-find server-program))
                  (not (executable-find dictionary-program)))
             (let ((base-path "/tmp/yaskkserv2"))
               (unless (f-exists? base-path)
                 (call-process "git" nil nil t  "clone" "https://github.com/wachikun/yaskkserv2" "/tmp/yaskkserv2"))
               (call-process "cargo" nil nil t "build" "--release" "--manifest-path" (expand-file-name "Cargo.toml" base-path))
               (unless (f-exists? server-program)
                 (f-copy (expand-file-name "target/release/yaskkserv2" base-path) server-program))
               (unless (f-exists? dictionary-program)
                 (f-copy (expand-file-name "target/release/yaskkserv2_make_dictionary" base-path) dictionary-program))
               ))
            (t
             (let* ((target (cond ((eq window-system 'ns) "apple-darwin")
                                  (t "uknown-linux-gnu")))
                    (path (format "https://github.com/wachikun/yaskkserv2/releases/download/%s/yaskkserv2-%s-x86_64-%s.tar.gz" my:yaskkserv2-version my:yaskkserv2-version target)))
               (call-process "curl" nil nil t "-L" path "-o" "/tmp/yaskkserv2.tar.gz")
               (call-process "tar" nil nil t "-zxvf" "/tmp/yaskkserv2.tar.gz" "-C" my:user-local-exec-path "--strip-components" "1"))))))
#+end_src


