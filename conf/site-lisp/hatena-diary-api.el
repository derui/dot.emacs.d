(require 'url)
(require 'xml)
(require 'sha1-el)
(eval-when-compile (require 'cl))

(defgroup hatena nil
  "Hatena."
  :group 'applications)

(defcustom hatena:username-function
  #'(lambda () (read-string "[Hatena] User name: "))
  "Function to retrieve user name for Hatena."
  :type 'function
  :group 'hatena)

(defcustom hatena:password-function
  #'(lambda () (read-passwd "[Hatena] Password: "))
  "Function to retrieve password for Hatena."
  :type 'function
  :group 'hatena)

(defvar hatena:username nil
  "User name for Hatena.")
(defvar hatena:password nil
  "Password for Hatena.")

(defstruct (hatena:d:entry (:constructor hatena:d:make-entry))
  type id user title created updated source content)

(defsubst hatena-d-api-decode (str)
  (when (stringp str) (decode-coding-string str 'utf-8)))

(defsubst hatena-d-api-parse-date (date)
  (date-to-time (replace-regexp-in-string
                 "\\(\\+[0-9][0-9]\\):\\([0-9][0-9]\\)$" "\\1\\2" date)))

(defsubst hatena-d-api-id-epoch (id)
  ;; diary date and epoch
  (last (split-string (or (car-safe (last (split-string id ":"))) "") "-") 2))

(defsubst hatena-d-api-buffer-content ()
  (buffer-substring-no-properties (point-min) (point-max)))

(defsubst hatena-d-api-iso-date ()
  (format-time-string "%Y-%m-%dT%TZ" (current-time) t))

(defsubst hatena-d-api-update-entry (entry new)
  (setf (hatena:d:entry-id entry) (hatena:d:entry-id new))
  (setf (hatena:d:entry-user entry) (hatena:d:entry-user new))
  (setf (hatena:d:entry-title entry) (hatena:d:entry-title new))
  (setf (hatena:d:entry-created entry) (hatena:d:entry-created new))
  (setf (hatena:d:entry-updated entry) (hatena:d:entry-updated new))
  (setf (hatena:d:entry-content entry) (hatena:d:entry-content new)))

;; APIs

(defsubst hatena:d:api:uri (type user &rest args)
  (let ((base (format "http://d.hatena.ne.jp/%s/atom/%s" user type)))
    (mapconcat #'identity (cons base args) "/")))

(defsubst hatena:d:api:member-uri (type user date epoch)
  (cond ((eq type 'blog) (hatena:d:api:uri type user date epoch))
        ((eq type 'draft) (hatena:d:api:uri type user epoch))))

(defun hatena:username ()
  "User name for Hatena."
  (when (and (not hatena:username) (functionp hatena:username-function))
    (setq hatena:username (funcall hatena:username-function)))
  (unless hatena:username (error "No user name specified"))
  hatena:username)

(defun hatena:password ()
  "Password for Hatena."
  (when (and (not hatena:password) (functionp hatena:password-function))
    (setq hatena:password (funcall hatena:password-function)))
  (unless hatena:password (error "No password specified"))
  hatena:password)

(defun hatena:d:api:wsse ()
  "Make X-WSSE HTTP header field.
`hatena:username' and `hatena:password' are used to make the
header field."
  (let* ((user (hatena:username))
         (created (hatena-d-api-iso-date))
         (nonce (sha1 created))
         (digest (concat nonce created (hatena:password)))
         (digest (base64-encode-string (sha1-binary digest)))
         (nonce (base64-encode-string nonce)))
    (cons "X-WSSE"
          (mapconcat #'identity
                     (list (format "UsernameToken Username=\"%s\"" user)
                           (format "PasswordDigest=\"%s\"" digest)
                           (format "Nonce=\"%s\"" nonce)
                           (format "Created=\"%s\"" created))
                     ", "))))

(defun hatena:d:api:request (uri &optional method headers data)
  "Request URI with METHOD.
If METHOD is nil, \"GET\" is used for non-data requests and
\"POST\" is used for data requests. If HEADERS is non-nil, they
are appended to the request header in addition to X-WSSE header
generated by `hatena:d:api:wsse'."
  (let* ((url-request-method (or method (or (and data "POST") "GET")))
         (headers (cons (hatena:d:api:wsse) headers))
         (url-request-extra-headers headers)
         (url-request-data (and data (encode-coding-string data 'utf-8)))
         (buf (url-retrieve-synchronously uri)))
    (prog1
        (with-current-buffer buf
          (let ((txt (hatena-d-api-buffer-content))
                (xml (xml-parse-region (point-min) (point-max))))
            (cons (split-string txt "\n") xml)))
      (kill-buffer buf))))

(defun hatena:d:api:entries (type &optional user page)
  "Retrieve Hatena::Diary entries.
TYPE must be either `blog' or `draft'. If USER is nil then the
value of `hatena:username' is used. If PAGE is non-nil, it is
used to specify the page number of entry list."
  (let* ((user (or user (hatena:username)))
         (uri (hatena:d:api:uri type user))
         (uri (if (integerp page) (format "%s?page=%d" uri page) uri))
         (res (hatena:d:api:request uri)))
    (mapcar #'(lambda (entry)
                (let ((entry (hatena-d-api-decode-entry entry)))
                  (setf (hatena:d:entry-type entry) type)
                  entry))
            (loop for e in (cdr (car (cdr res)))
                  when (and (listp e) (equal (nth 0 e) 'entry))
                  collect e))))

(defun hatena:d:api:save (entry &optional update publish)
  "Save ENTRY.
If UPDATE is non-nil, the current time is specified as an update
time. If PUBLISH is non-nil and ENTRY is a draft entry, then the
entry is published as a blog entry.

After the request is accepted successfully, ENTRY is updated
using the response of the request."
  (unless (hatena:d:entry-type entry) (error "Entry type not specified"))
  (let* ((type (hatena:d:entry-type entry))
         (user (hatena:d:entry-user entry))
         (title (hatena:d:entry-title entry))
         (header (and publish '(("X-HATENA-PUBLISH" . "1"))))
         (content (hatena:d:entry-source entry))
         method uri data)
    (cond
     ((hatena:d:entry-id entry) ; update
      (setq uri (hatena-d-api-entry-member-uri entry) method "PUT"))
     (t                         ; new post
      (setq uri (hatena:d:api:uri type user) method "POST" update t)))
    (setq data (hatena-d-api-data-xml title content update))
    (let ((result (hatena:d:api:request uri method header data)))
      (when (eq (car-safe (car-safe (cdr result))) 'entry)
        (let ((new-entry (hatena-d-api-decode-entry (cadr result))))
          (hatena-d-api-update-entry entry new-entry)))
      (caar result))))

(defun hatena:d:api:delete (entry)
  "Delete ENTRY."
  (let ((uri (hatena-d-api-entry-member-uri entry))
        (method "DELETE"))
    (caar (hatena:d:api:request uri method))))

(defun hatena:d:api:publish (entry)
  "Publish ENTRY. ENTRY must be a draft entry."
  (unless (eq (hatena:d:entry-type entry) 'draft)
    (error "Publishing non-draft entry"))
  (hatena:d:api:get-source entry)
  (hatena:d:api:save entry nil t))

(defun hatena:d:api:get-source (entry &optional force)
  "Return source of ENTRY.
If no source is stored in ENTRY or FORCE is non-nil, then
retrieve it from the remote service."
  (when (and (or force (not (hatena:d:entry-source entry)))
             (hatena:d:entry-id entry))
    (let* ((uri (hatena-d-api-entry-member-uri entry))
           (source (nth 1 (hatena:d:api:request uri)))
           (content (hatena-d-api-decode
                     (nth 2 (or (assq 'hatena:syntax source)
                                (assq 'content source))))))
      (setf (hatena:d:entry-source entry) content)))
  (hatena:d:entry-source entry))

;; internal functions

(defun hatena-d-api-entry-member-uri (entry)
  (destructuring-bind (date epoch)
      (hatena-d-api-id-epoch (hatena:d:entry-id entry))
    (let ((type (hatena:d:entry-type entry))
          (user (hatena:d:entry-user entry)))
      (hatena:d:api:member-uri type user date epoch))))

(defun hatena-d-api-decode-entry (entry)
  (let ((id (nth 2 (assq 'id entry)))
        (user (nth 2 (nth 3 (assq 'author entry))))
        (title (hatena-d-api-decode (nth 2 (assq 'title entry))))
        (created (hatena-d-api-parse-date (nth 2 (assq 'published entry))))
        (updated (hatena-d-api-parse-date (nth 2 (assq 'updated entry))))
        (content (hatena-d-api-decode (nth 2 (assq 'content entry)))))
    (hatena:d:make-entry
     :id id :user user :title title :content content
     :created created :updated updated)))

(defun hatena-d-api-escape (s)
  (mapc #'(lambda (x) (setq s (replace-regexp-in-string (car x) (cdr x) s)))
        '(("&" . "&amp;") (">" . "&gt;") ("<" . "&lt;") ("\"" . "&quot;")))
  s)

(defun hatena-d-api-data-xml (title content update)
  (let* ((date (format "\n<updated>%s</updated>" (hatena-d-api-iso-date)))
         (update (or (and update date) ""))
         (title (hatena-d-api-escape title))
         (content (hatena-d-api-escape content)))
    (format "<entry xmlns=\"http://purl.org/atom/ns#\">
  <title>%s</title>
  <content type=\"text/plain\">%s</content>%s
</entry>" title content update)))

(provide 'hatena-diary-api)
;;; hatena-diary-api.el ends here
