;; el-getで読み込んだhelmを有効にするための設定を行う。
(require 'helm)
(require 'helm-config)
;; helmを有効にする。また、基本的な設定を追加。
;; helmを利用したbasic completionを利用するが、全てが強制的にhelmになってしまうため、
;; ここでは避ける。
;; (helm-mode 1)

(setq helm-c-filelist-file-name "/tmp/all.filelist")
(setq helm-grep-candidates-fast-directory-regexp "^/tmp")

(defun my:helm ()
  "Helm command for you.

It is automatically generated by `helm-migrate-sources'."
  (interactive)
  (helm-other-buffer
     '(helm-c-source-buffers+
       helm-source-recentf
       helm-source-files-in-current-dir
       helm-source-bookmarks
       helm-source-buffer-not-found)
     " *helm*"))

;; ディレイは0.2秒
(setq helm-input-idle-delay 0.02)

;; 候補のディレクトリが一つしかない場合に、自動的に展開しない
(setq helm-ff-auto-update-initial-value nil)

;; 検索文字列を入力しおわってから検索に入る。間隔は0.01秒にしておく。
(setq helm-idle-delay 0.01)
(defadvice helm-check-minibuffer-input (around sit-for activate)
  (if (sit-for helm-idle-delay t)
      ad-do-it))

;; helmの描画をwindow単位にする
(setq helm-save-configuration-functions
      '(set-window-configuration . current-window-configuration))

;; windowに表示されていない部分から更新する
(setq helm-quick-update t)

;; 候補がひとつしかない場合は、選択した時点で実行する
(setq helm-execute-action-at-once-if-one t)

;; emacsの終了時に、履歴を保存する
(remove-hook 'kill-emacs-hook 'helm-c-adaptive-save-history)

;; C-v/M-vで前後のsourceに移動する
(define-key helm-map (kbd "C-v") 'helm-next-source)
(define-key helm-map (kbd "M-v") 'helm-previous-source)
;; C-_でpersistent-actionを実行する
(define-key helm-map (kbd "C-_") 'helm-execute-persistent-action)
(define-key helm-map (kbd "C-h") 'backward-delete-char)

;; helm中から別のソースを読みだす。
(defvar helm-source-select-buffer "*helm source select*")
(defvar helm-c-source-call-source
  `((name . "Call helm source")
    (candidate-number-limit)
    (candidates
     . (lambda ()
         (loop for vname in (all-completions "helm-c-source-" obarray)
               for var = (intern vname)
               for name = (ignore-errors (assoc-default 'name (symbol-value var)))
               if name collect
               (cons (format "%s `%s'"
                             name (propertize vname 'face 'font-lock-variable-name-face))
                     var))))
    (action
     . (("Invoke helm with selected source"
         .
         (lambda (candidate)
           (setq helm-candidate-number-limit 9999)
           (helm candidate nil nil nil nil
                     helm-source-select-buffer)))
        ("Describe variable" . describe-variable)
        ("Find variable" . find-variable)))
    (persistent-action . describe-variable)
    (persistent-help . "Show description of this source")))

(defun helm-call-source-from-helm ()
  "Call helm source within `helm' session."
  (interactive)
  (setq helm-input-idle-delay 0)
  (helm-set-sources '(helm-c-source-call-source)))
(define-key helm-map (kbd "C-r") 'helm-call-source-from-helm)

;; 二つ目のアクションを実行する
(define-key helm-map (kbd "C-e") 'helm-select-2nd-action-or-end-of-line)

;; 現在選択している部分にマークをつける
(define-key helm-map (kbd "C-SPC") 'helm-toggle-visible-mark)

;; 現在選択しているデータをミニバッファにyankする。
(define-key helm-map (kbd "M-[") 'helm-prev-visible-mark)
(define-key helm-map (kbd "M-]") 'helm-next-visible-mark)

;; C-;でhelmを起動する
(global-set-key (kbd "C-;") 'my:helm)

;; (auto-install-from-emacswiki "anything-migemo.el")
(defvar helm-test-candidate-list nil)
(defun* helm-test-candidates
    (sources &optional (input "")
             (compile-source-functions
              helm-compile-source-functions-default))
  "Test helper function for anything.
Given pseudo `helm-sources' and `helm-pattern', returns list like
  ((\"source name1\" (\"candidate1\" \"candidate2\"))
   (\"source name2\" (\"candidate3\" \"candidate4\")))"
  (let ((helm-test-mode t)
        helm-enable-shortcuts
        helm-candidate-cache
        (helm-compile-source-functions compile-source-functions)
        helm-before-initialize-hook
        helm-after-initialize-hook
        helm-update-hook
        helm-test-candidate-list)
    (get-buffer-create helm-buffer)
    (helm-initialize nil input sources)
    (helm-update)
    ;; test-mode spec: select 1st candidate!
    (with-current-buffer helm-buffer
      (forward-line 1)
      (helm-mark-current-line))
    (prog1
        helm-test-candidate-list
      (helm-cleanup))))

;; persistent-actionを実行する際に、overlayを作成する
(defvar my:helm-c-persistent-highlight-overlay
  (make-overlay (point) (point)))

;; 実行時に終了しないようなpersistent-actionを実行した際で、かつ
;; 行が選択される場合に、選択された行をハイライトする
(defadvice helm-mark-current-line
  (after helm-execute-persistent-action first (&rest ret) activate)
  (when (and (helm-window)
             (helm-get-selection)
             (not (assoc 'explicit-persistent-action (helm-get-current-source)))
             (assoc 'persistent-action (helm-get-current-source)))
    (save-excursion
      (helm-execute-persistent-action))))


;; マッチした行にオーバーレイを置く。
(defun my:helm-persistent-highlight-point (start &optional end buf face rec)
  (goto-char start)
  (when (overlayp my:helm-c-persistent-highlight-overlay)
    (move-overlay my:helm-c-persistent-highlight-overlay
                  start
                  (or end (line-end-position))
                  buf))
  (overlay-put my:helm-c-persistent-highlight-overlay 'face (or face 'highlight))
  (when rec
    (recenter)))

;; helm-grepで特定の行に移動する際に、highlightを行う
(add-hook 'helm-grep-goto-hook
          (lambda ()
            (when helm-in-persistent-action
              (my:helm-persistent-highlight-point (point-at-bol) (point-at-eol)))))

;; helmの終了時に、persistent-actionで設置したoverlayを除去する
(add-hook 'helm-cleanup-hook
          (lambda ()
            (when (overlayp my:helm-c-persistent-highlight-overlay)
              (delete-overlay my:helm-c-persistent-highlight-overlay))))


;; helm-c-source-buffersで、現在開いているバッファを対象としない
(setq helm-allow-skipping-current-buffer t)

(defvar helm-c-source-buffers+
  '((name . "Buffers+")
    (candidates . helm-c-buffer-list)
    (migemo)
    (type . buffer)))

;; helm-c-source-buffersについて、persistent-actionを定義する
(add-to-list 'helm-c-source-buffers+
             '(persistent-action . (lambda (name)
                                     (flet ((kill (item)
                                                  (kill-buffer item)
                                                  (helm-delete-current-selection)
                                                  (message "Buffer <%s> Killed" item))
                                            (goto (item)
                                                  (switch-to-buffer item)))
                                       (if current-prefix-arg
                                           (kill name)
                                         (goto name))))))

;; helm-c-source-files-in-dirを利用できるようにする。
(defun helm-c-transform-file-name-nondirectory (files)
  (mapcar (lambda (f) (cons (file-name-nondirectory f) f)) files))

(defun helm-c-source-files-in-dir (desc dir &optional match skip-opened-file)
  `((name . ,desc)
    (candidates . (lambda () (directory-files ,dir t ,match)))
    (candidate-transformer
     . (lambda (candidates)
         (helm-c-compose (list candidates)
                             '(,@(if skip-opened-file (list 'helm-c-skip-opened-files))
                               helm-c-transform-file-name-nondirectory))))
    (type . file)))

;; すべてのkill-ringを利用する
(setq helm-kill-ring-threshold 1)

;; 静的目次から、ヘルプを参照するためのヘルプ関数 from rubikitch
(defun helm-c-source-static-escript (symbol desc filename &rest other-attrib)
  `((name . ,desc)
    (candidates . ,symbol)
    ,@other-attrib
    (init
     . (lambda ()
         (unless (and (boundp ',symbol) ,symbol)
           (with-current-buffer (find-file-noselect ,filename)
             (setq ,symbol (split-string (buffer-string) "\n" t))))))
    (action
     ("Eval it"
      . (lambda (cand)
          (with-temp-buffer
            (insert cand)
            (cd ,(file-name-directory filename))
            (backward-sexp 1)
            (eval (read (current-buffer)))))))))
