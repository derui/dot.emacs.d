;;; init.el --- Init file for my own -*- lexical-binding: t; -*-

;; Author: derui <derutakayu@gmail.com>
;; Maintainer: derui <derutakayu@gmail.com>

;;; Commentary:

;;: Customization:

;;; Code:

;; DO NOT EDIT THIS FILE DIRECTLY

(defconst my:before-load-init-time (current-time))

;;;###autoload
(defun my:load-init-time ()
  "Loading time of user init files including time for `after-init-hook'."
  (let ((time1 (float-time
                (time-subtract after-init-time my:before-load-init-time)))
        (time2 (float-time
                (time-subtract (current-time) my:before-load-init-time))))
    (message (concat "Loading init files: %.0f [msec], "
                     "of which %.f [msec] for `after-init-hook'.")
             (* 1000 time1) (* 1000 (- time2 time1)))))
(add-hook 'after-init-hook #'my:load-init-time t)

(defvar my:tick-previous-time my:before-load-init-time)

;;;###autoload
(defun my:tick-init-time (msg)
  "Tick boot sequence at loading MSG."
  (when my:loading-profile-p
    (let ((ctime (current-time)))
      (message "---- %5.2f[ms] %s"
               (* 1000 (float-time
                        (time-subtract ctime my:tick-previous-time)))
               msg)
      (setq my:tick-previous-time ctime))))

(defun my:emacs-init-time ()
  "Emacs booting time in msec."
  (interactive)
  (message "Emacs booting time: %.0f [msec] = `emacs-init-time'."
           (* 1000
              (float-time (time-subtract
                           after-init-time
                           before-init-time)))))

(add-hook 'after-init-hook #'my:emacs-init-time)

(defvar my:setup-tracker--level 0)
(defvar my:setup-tracker--parents nil)
(defvar my:setup-tracker--times nil)
(defvar my:setup-tracker-enabled nil)

(when my:setup-tracker-enabled

  (when load-file-name
    (push load-file-name my:setup-tracker--parents)
    (push (current-time) my:setup-tracker--times)
    (setq my:setup-tracker--level (1+ my:setup-tracker--level)))

  (add-variable-watcher
   'load-file-name
   (lambda (_ v &rest __)
     (cond ((equal v (car my:setup-tracker--parents))
            nil)
           ((equal v (cadr my:setup-tracker--parents))
            (setq my:setup-tracker--level (1- my:setup-tracker--level))
            (let* ((now (current-time))
                   (start (pop my:setup-tracker--times))
                   (elapsed (+ (* (- (nth 1 now) (nth 1 start)) 1000)
                               (/ (- (nth 2 now) (nth 2 start)) 1000))))
              (with-current-buffer (get-buffer-create "*my:setup-tracker*")
                (save-excursion
                  (goto-char (point-min))
                  (dotimes (_ my:setup-tracker--level) (insert "> "))
                  (insert
                   (file-name-nondirectory (pop my:setup-tracker--parents))
                   " (" (number-to-string elapsed) " msec)\n")))))
           (t
            (push v my:setup-tracker--parents)
            (push (current-time) my:setup-tracker--times)
            (setq my:setup-tracker--level (1+ my:setup-tracker--level)))))))

(add-to-list 'native-comp-eln-load-path (expand-file-name "eln-cache" user-emacs-directory))

(eval-when-compile
  (require 'cl-lib))

(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 6))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

(eval-when-compile
  (straight-use-package 'setup)
  (require 'setup)

  ;; straightを使えるようにする
  (setup-define :straight
    (lambda (recipe)
      `(unless (straight-use-package ',recipe)
         ,(setup-quit)))
    :documentation
    "Install RECIPE with `straight-use-package'.
This macro can be used as HEAD, and will replace itself with the
first RECIPE's package."
    :repeatable t
    :shorthand (lambda (sexp)
                 (let ((recipe (cadr sexp)))
                   (if (consp recipe)
                       (car recipe)
                     recipe)))))

(defgroup my nil "My custom group" :group 'configuration)
(defcustom my:font-size 10.5
  "current font size"
  :group 'my
  :type 'number)
(defcustom my:font-family "HackGen"
  "current font family"
  :group 'my
  :type 'string)
(defcustom my:input-method 'japanese-mozc
  "input method"
  :group 'my
  :type 'symbol)

(defcustom my:ispell-regexp-ja "[一-龠ぁ-🈀ァ-𛀀ー・、。々]+"
  "Regular expression to match a Japanese word.
The expression can be [^\000-\377]+, [^!-~]+, or [一-龠ぁ-🈀ァ-𛀀ー・、。々]+"
  :group 'my
  :type 'string)

(defcustom my:trailing-whitespace-exclude-modes
  '(org-mode)
  "Do not trailing whitespace in these modes"
  :group 'my
  :type '(symbol))
(defcustom my:user-local-exec-path
  "~/.local/bin"
  "The location user-local executable path"
  :group 'my
  :type 'string)

(defcustom my:langtool-version
  "4.2"
  "The version of Langtool"
  :group 'my
  :type 'string)

(defcustom my:langtool-cli-path
  (expand-file-name (locate-user-emacs-file
                     (format "share/LanguageTool-%s/languagetool-commandline.jar"
                             my:langtool-version)))
  "The path of langtool CLI"
  :group 'my
  :type 'string)

(defvar skk-user-directory (expand-file-name "skk" user-emacs-directory))
;; SKK server(利用するのはyaskkserv2を利用する
(defcustom my:use-skkserver t
  "Use skk server or not"
  :group 'my
  :type 'boolean)

;; SKK serverをbuildする(要cargo)
(defcustom my:build-skkserver
  nil
  "Build skk server if not available in system"
  :group 'my
  :type 'boolean)

;; yaskkserv2のバージョン
(defcustom my:yaskkserv2-version "0.1.1"
  "The version of yaskkserv2"
  :group 'my
  :type 'string)

(defcustom my:use-posframe t
  "Use posframe entirely"
  :group 'my
  :type 'boolean)

(defcustom my:org-roam-db-location
  "~/.emacs.d/share/org-roam.db"
  "The location of database that is used by org-roam"
  :group 'my
  :type 'string)

(defcustom my:org-roam-directory
  "~/Dropbox/git/roam"
  "The location of roam files"
  :group 'my
  :type 'directory)

(defcustom my:org-roam-dailies-directory
  "~/Dropbox/git/roam-daily"
  "The location of roam-daily files"
  :group 'my
  :type 'directory)

(defcustom my:org-roam-index-file
  (expand-file-name "index.org" my:org-roam-directory)
  "The location of index file"
  :group 'my
  :type 'file)

(defcustom my:mozc-el-locate nil
  "Location of mozc.el"
  :group 'my
  :type 'file)

(defcustom my:mozc-helper-locate nil
  "Location of emacs-mozc-helper"
  :group 'my
  :type 'file)

(defcustom my:virtualenv-path nil
  "Location of virtualenv's environment"
  :group 'my
  :type 'file)

(defcustom my:roswell-path nil
  "Location of roswell"
  :group 'my
  :type 'file)

(defcustom my:use-mozc-el nil
  "Use mozc as input method"
  :group 'my
  :type 'boolean)

(defcustom my:migemo-command nil
  "The path of migemo-like executable"
  :group 'my
  :type 'file)

(defcustom my:migemo-dictionary nil
  "The path of dictionaries for migemo"
  :group 'my
  :type 'directory)

(defcustom my:cargo-path nil
  "The path of cargo executable"
  :group 'my
  :type 'file)

(defcustom my:rust-analyzer-version nil
  "The path of rust-analyzer executable"
  :group 'my
  :type 'file)

(let ((user-env (locate-user-emacs-file "conf/user-env.el")))
  (load user-env t))

(add-to-list 'exec-path (expand-file-name "~/.npm/bin"))
(add-to-list 'exec-path (expand-file-name "~/.asdf/shims"))
(add-to-list 'exec-path "/usr/local/bin")
(add-to-list 'exec-path "/usr/bin")
(add-to-list 'exec-path "/usr/sbin")
(add-to-list 'exec-path my:user-local-exec-path)
(add-to-list 'exec-path (expand-file-name "bin" my:roswell-path))
(add-to-list 'exec-path (expand-file-name "bin" my:cargo-path))

(when (eq system-type 'darwin)
  ;; altとMetaを入れ替える
  (setq mac-option-modifier 'alt)
  (setq mac-command-modifier 'meta)

  ;; macOSで描画がかなり遅いのを解消できるかもしれない設定
  (add-to-list 'default-frame-alist '(inhibit-double-buffering . t)))

(setq font-lock-support-mode 'jit-lock-mode)

(defface my-face-b-2 '((t (:background "gray26"))) "face for tab" :group 'my)
(defface my-face-u-1 '((t (:foreground "SteelBlue" :underline t))) "" :group 'my)
(defvar my-face-b-2 'my-face-b-2)
(defvar my-face-u-1 'my-face-u-1)

(defun my:font-lock-mode (&rest _)
  (font-lock-add-keywords
   major-mode
   '(("\t" 0 my-face-b-2 append)
     ("[ \t]+$" 0 my-face-u-1 append))))
(advice-add 'font-lock-mode :before 'my:font-lock-mode)

(setup *face
  (with-eval-after-load 'bookmark
    (with-eval-after-load 'modus-themes
      (set-face-attribute 'bookmark-face nil :foreground 'unspecified :background 'unspecified :inherit 'unspecified))))

(setopt show-trailing-whitespace t)

(setup *mode-line-face
  ;; mode lineをvariable pitchではなく等幅フォントを利用する。
  (set-face-attribute 'mode-line-active nil :inherit 'mode-line))

(global-font-lock-mode +1)

(show-paren-mode +1)

(transient-mark-mode +1)

;; pixelベースのスクロール処理
(pixel-scroll-precision-mode +1)

(scroll-bar-mode -1)
(menu-bar-mode -1)
(tool-bar-mode -1)
(line-number-mode -1)
(column-number-mode -1)
;; 小さいサイズのwindow は拡張するだけにする
(setopt resize-mini-windows 'grow-only)

(defun my:run-local-vars-mode-hook ()
  "Run `major-mode' hook after the local variables have been processed."
  (run-hooks (intern (concat (symbol-name major-mode) "-local-vars-hook"))))
(add-hook 'hack-local-variables-hook 'my:run-local-vars-mode-hook)

(defun my:save-all-buffers ()
  (save-some-buffers "!"))

(add-hook 'focus-out-hook #'my:save-all-buffers)

(setopt sentence-end-double-space nil)

(setup browse-url
  (cond
   ((executable-find "firefox-bin")
    (progn
      (setq browse-url-browser-function #'browse-url-firefox)
      (setq browse-url-generic-program "firefox-bin")
      (setq browse-url-firefox-program "firefox-bin")))
   ((executable-find "chromium")
    (progn
      (setq browse-url-browser-function #'browse-url-chromium)
      (setq browse-url-generic-program "chromium")))
   ((executable-find "vivaldi")
    (progn
      (setq browse-url-browser-function #'browse-url-chromium)
      (setq browse-url-generic-program "vivaldi")))))

(setup server
  (:when-loaded
    ;; serverで開いたバッファをkillする
    (setopt server-kill-new-buffers t)
    (setopt server-temp-file-regexp "\\`/tmp/Re\\|/draft\\|COMMIT_EDITMSG\\'"))

  (:with-mode temporary-edit-mode
    (:hook-into server-switch-hook))

  (:with-hook after-init-hook
    (:hook server-start))

  ;; define server-editing specialized minor mode
  (defun my:copy-input-and-exit ()
    "Copy the current input to the kill ring and exit."
    (interactive)
    (let ((buffer (current-buffer))
          (select-enable-clipboard t))

      (my:copy-with-system-clipboard (buffer-substring-no-properties (point-min) (point-max)))

      (or (delete-frame)
          (server-edit))

      (with-current-buffer buffer
        (let (kill-buffer-hook kill-buffer-query-functions)
          (set-buffer-modified-p 'nil)
          (kill-buffer)))))
  
  (define-minor-mode temporary-edit-mode
    "Temporary editing mode with server"
    :keymap (let ((map (make-sparse-keymap)))
              (define-key map (kbd "C-c C-y") 'my:copy-input-and-exit)
              map)))

(setup dired
  (defun my:dired-do-native-comp ()
    "選択されているファイルをnative-compする"
    (interactive)
    (when-let* ((file (dired-get-filename))
                (enabled (fboundp 'native-compile-async)))
      (condition-case err
          (native-compile-async file)
        (error (dired-log "native-compile error for %s:\n%s\n" file err)))))
  
  (defun my:dired-next-buffer-on-window ()
    "現在のdiredバッファ以外で、かつ他のwindowに存在しているdired bufferに移動する。
対象になるバッファが無い場合は何もしない"
    (interactive)
    (when-let ((next-dired-buffer (seq-find
                                   (lambda (buf)
                                     (and (eq 'dired-mode (buffer-local-value 'major-mode buf))
                                          (not (eq (current-buffer) buf))
                                          (get-buffer-window buf)))
                                   (buffer-list))))
      (select-window (get-buffer-window next-dired-buffer))))

  (defun my:dired-balance ()
    "diredを使うにあたってよく利用する状態になるように調整する.

- 今のdired bufferが side-window用の場合は何もしない
- windowが一つしかない場合、vertical splitをする
- windowが３つ以上ある場合、2つにする
- windowが２つあるが、片方がdired bufferではない場合、current bufferを表示する
"
    (interactive)
    (unless (window-parameter (selected-window) 'window-side)
      (when (< 2 (count-windows))
        (delete-other-windows))
      (when (= 1 (count-windows))
        (split-window-horizontally))
      (let* ((current-w (get-buffer-window (current-buffer)))
             (b (seq-find (lambda (buf)
                            (let ((w2 (get-buffer-window buf)))
                              ;; side windowは対象にしない
                              (and (not (equal current-w w2))
                                   (not (window-parameter w2 'window-side)))
                              ))
                          (buffer-list)))
             (w (get-buffer-window b))
             (other-buffer-mode (buffer-local-value 'major-mode b)))
        (when (not (eq 'dired-mode other-buffer-mode))
          (save-current-buffer
            (select-window w)
            (switch-to-buffer (current-buffer))
            )
          ))))

  (:with-mode dired-mode
    ;; wdiredを有効にする
    (:bind
     "N" my:dired-do-native-comp
     ;; dired内でもhjklで移動できるようにしておく
     "h" dired-up-directory
     "l" dired-find-file
     "j" dired-next-line
     "k" dired-previous-line
     ;; 2画面ファイラっぽく、次に開いているdiredバッファに移動できるようにする
     "<tab>" my:dired-next-buffer-on-window
     "." my:dired-balance
     (kbd "C-w") my:window-transient
     ))

  (:when-loaded
    ;; diredでファイルをコピーする際に、コピー先をもう一つのdiredに切り替える
    (setopt dired-dwim-target t)
    (setopt dired-recursive-copies 'always)
    (setopt dired-recursive-deletes 'always)
    (setopt dired-listing-switches "-al --group-directories-first")
    ;; 標準で用意された、新規にdiredを開かないようにするための処理
    (setopt dired-kill-when-opening-new-dired-buffer t)

    (when (eq system-type 'darwin)
      ;; macOSの場合、lsがcoreutilsとは別物なので、coreutils版の方を利用するように切り替える
      (setopt insert-directory-program "gls")
      )))

(setup uniquify
  (:when-loaded
    (setopt uniquify-buffer-name-style 'forward)
    (setopt uniquify-separator "/")
    (setopt uniquify-after-kill-buffer-p t)    ; rename after killing uniquified
    (setopt uniquify-ignore-buffers-re "^\\*") ; don't muck with special buffers
    )
  (:require uniquify))

(setup shell
  (:when-loaded
    (setopt explicit-shell-file-name "/bin/bash")
    (setopt shell-file-name "/bin/bash")
    (setq shell-command-switch "-c"))
  
  (setenv "EMACS" "t"))

(setup recentf
  (:when-loaded
    ;; 最大1000まで保存するようにする
    (setopt recentf-max-saved-items 1000)
    ;; /tmpのものはそもそも残らないようにする
    (add-to-list 'recentf-exclude "/tmp/*"))
  
  (:hook-into emacs-startup-hook))

(setup dabbrev
  (:global
   "M-/" dabbrev-completion
   "C-M-/" dabbrev-expand
   ))

(setup project
  (defun my:project-try-nodejs (dir)
    "Find a super-directory of DIR containing a package.json file."
    (let ((dir (locate-dominating-file dir "package.json")))
      (and dir (cons 'explicit dir))))

  (cl-defmethod project-root ((project (head explicit)))
    (cdr project))

  (:when-loaded
    (add-hook 'project-find-functions #'my:project-try-nodejs)
    )
  )

(setup files
  (:require files)
  ;; 5秒操作がなかったら自動保存
  (setopt auto-save-interval 5)
  (auto-save-visited-mode +1))

(setup elec-pair
  (add-hook 'prog-mode-hook #'electric-pair-local-mode))

(setup isearch
  (:with-mode isearch-mode
    (:bind
     "C-l" consult-line
     "C-g" isearch-cancel  ; abortだと戻ってしまうため、Cancel にしている

     ;; C-hで文字の削除
     "C-h" isearch-delete-char

     ;; avyで結果に移動する
     "C-j" avy-isearch
     ))

  (:when-loaded
    ;; isearchでwrapするときにdingを鳴らさない
    (setopt isearch-wrap-pause t)
    ;; 検索する方向を変えるときに、再度検索し直す
    (setopt isearch-repeat-on-direction-change t)

    ;; isearchを実行しているときにlazinessに件数をカウントする
    (setopt isearch-lazy-count nil)
    (setopt lazy-count-prefix-format "(%s/%s) ")
    (setopt lazy-count-suffix-format nil)

    ;; highlightをlazyにする
    (setopt isearch-lazy-highlight t)
    (setopt lazy-highlight-no-delay-length 4)))

(setup *key-binding
  (:global
   (kbd "C-z") nil
   (kbd "C-h") #'backward-delete-char
   (kbd "M-?") #'help-for-help
   (kbd "C-m") #'newline-and-indent
   (kbd "C-x /") #'dabbrev-expand
   (kbd "C-x ,") #'delete-region
   (kbd "M-;") #'comment-dwim
   (kbd "C-x C-b") #'ibuffer
   (kbd "C-/") #'undo
   (kbd "M-y") #'consult-yank-pop
   (kbd "C-<tab>") #'completion-at-point
   (kbd "M-i") #'backward-paragraph
   (kbd "M-o") #'forward-paragraph
   (kbd "C-;") #'consult-buffer
   (kbd "<escape>") #'modalka-mode
   (kbd "<f2>") nil
   )
  (define-key read-expression-map (kbd "TAB") #'completion-at-point)
  )

(setup *advices
  (defun my:no-kill-new-duplicate (yank &optional _)
    "kill-ringにおなじ内容が保存されないようにする"
    (setq kill-ring (delete yank kill-ring)))
  (advice-add 'kill-new :before #'my:no-kill-new-duplicate)

  (defun my:no-kill-empty-only-content (f &rest args)
    "空文字列に相当する場合はkill-ringに保存しないようにする"
    (let* ((yank (car args)))
      (unless (string-blank-p yank)
        (apply f args))))
  
  (advice-add 'kill-new :around #'my:no-kill-empty-only-content))

(when window-system
  (cond
   ((eq window-system 'x)
    ;; window-systemがxの場合に実行される初期化elisp
    ;; x11を利用している場合、クリップボードの連携を有効にする。
    (setopt select-enable-clipboard t)
    (setopt select-enable-primary nil))
   ((eq window-system 'pgtk)
    (setq my:wl-copy-process nil)
    (defun my:wl-copy (text)
      (setq my:wl-copy-process (make-process :name "wl-copy"
                                             :buffer nil
                                             :command '("wl-copy" "-f" "-n")
                                             :connection-type 'pipe
                                             :noquery t))
      (process-send-string my:wl-copy-process text)
      (process-send-eof my:wl-copy-process))
    (defun my:wl-paste ()
      (if (and my:wl-copy-process (process-live-p my:wl-copy-process))
          nil ; should return nil if we're the current paste owner
        (shell-command-to-string "wl-paste -n | tr -d \r")))
    (setq interprogram-cut-function #'my:wl-copy)
    (setq interprogram-paste-function #'my:wl-paste)
    )))

(setup *utility-functions

  (defun my:buffer-name-list ()
    "Get list of buffer name"
    (mapcar (function buffer-name) (buffer-list)))

  (defun my:delete-trailing-whitespace ()
    "delete trailing whitespace if the buffer is associated a major mode in `my:trailing-whitespace-exclude-modes'"
    (unless (seq-some (lambda (x) (eq major-mode x)) my:trailing-whitespace-exclude-modes)
      (delete-trailing-whitespace)))

  (defun my:minor-mode-active-p (mode)
    "return specified minor mode is active or not"
    (let ((active-modes (cl-remove-if-not (lambda (it) (and (boundp it) (symbol-value it))) minor-mode-list)))
      (member mode active-modes)))

  (defun my:copy-with-system-clipboard (str)
    "Copy passed string to system clipboard.
This function does not add `str' to the kill ring."
    (when (display-graphic-p)
      (cond
       ((eq system-type 'darwin)
        (let ((proc (make-process :name "pbcopy" :buffer nil :command '("pbcopy") :connection-type 'pipe)))
          (process-send-string proc str)
          (process-send-eof proc)
          (kill-process proc)))
       ((and (eq system-type 'gnu/linux)
             (eq window-system 'pgtk)
             (executable-find "wl-copy"))
        (let ((proc (make-process :name "wl-copy"
                                  :buffer nil
                                  :command '("wl-copy" "-f" "-n")
                                  :connection-type 'pipe)))
          (process-send-string proc str)
          (process-send-eof proc)
          (kill-process proc)))
       (t
        nil)
       )))
  )

(defun my:treesit-expand-region--between-node (a b)
  "`(A B)' の間に存在するnodeを取得する"
  (let ((start (min a b))
        (end (max a b)))
    (treesit-parent-until
     (treesit-node-at start)
     (lambda (node) (< end (treesit-node-end node)))))
  )

(defun my:treesit-expand-region--parent-node ()
  "pointの位置にあるnodeの親を取得する"
  (when-let* ((node (if (region-active-p)
                        (my:treesit-expand-region--between-node (region-beginning) (region-end))
                      (treesit-node-at (point)))))
    (goto-char (treesit-node-start node))
    (set-mark (treesit-node-end node))
    (activate-mark))
  )

(defun my:treesit-expand-region ()
  "treesitが有効な場合にexpand regionを実施する。treesitが有効ではない場合はpuniを利用する"
  (interactive)
  (if (and (functionp 'treesit-available-p)
           (treesit-available-p)
           (treesit-language-at (point))
           )
      (my:treesit-expand-region--parent-node)
    (puni-expand-region))
  )

(setup *extend-kill-region
  (defun my:kill-word-or-kill-region (f &rest args)
    "kill-regionにおいて、リージョンが選択されていない場合にはbackward-kill-wardを実行するように。"
    (if (and (called-interactively-p 'interactive) transient-mark-mode (not mark-active))
        (backward-kill-word 1)
      (apply f args)))

  (advice-add 'kill-region :around 'my:kill-word-or-kill-region))

(setup *extend-kill-line
  (defun my:kill-line-and-fixup (f &rest args)
    "kill-lineの際に、次の行の行頭に連続している空白を削除する"
    (if (and (not (bolp)) (eolp))
        (progn
          (forward-char)
          (fixup-whitespace)
          (backward-char))
      (apply f args)))

  (advice-add 'kill-line :around 'my:kill-line-and-fixup))

(defun my:upcase-char ()
  "upcase current point character"
  (interactive)
  (save-excursion
    (let* ((current-point (point))
           (upcased (s-upcase (buffer-substring-no-properties current-point (1+ current-point)))))
      (replace-region-contents current-point (1+ current-point) (lambda () upcased)))))

(defun my:downcase-char ()
  "downcase current point character"
  (interactive)
  (save-excursion
    (let* ((current-point (point))
           (downcased (s-downcase (buffer-substring-no-properties current-point (1+ current-point)))))
      (replace-region-contents current-point (1+ current-point) (lambda () downcased)))))

(defun my:th-rename-tramp-buffer ()
  "trampで開いたファイルについて、バッファ名を変更する"
  (when (file-remote-p (buffer-file-name))
    (rename-buffer
     (format "%s:%s"
             (file-remote-p (buffer-file-name) 'method)
             (buffer-name)))))

(defun my:th-find-file-sudo (file)
  "Opens FILE with root privileges."
  (interactive "F")
  (set-buffer (find-file (concat "/sudo::" file))))

(add-hook 'find-file-hook #'my:th-rename-tramp-buffer)

(setup *scratch-expansion
  ;; (@> "*scratch*をkillできないようにする")
  (defun my:make-scratch (&optional arg)
    "scratchバッファをkillできないようにする"
    ;; "*scratch*" を作成して buffer-list に放り込む
    (set-buffer (get-buffer-create "*scratch*"))
    (funcall initial-major-mode)
    (erase-buffer)
    (when (and initial-scratch-message (not inhibit-startup-message))
      (insert initial-scratch-message))
    (or arg (progn (setq arg 0)
                   (switch-to-buffer "*scratch*")))
    (cond ((= arg 0) (message "*scratch* is cleared up."))
          ((= arg 1) (message "another *scratch* is created"))))

  (defun my:clear-scratch-when-kill-buffer ()
    (if (string= "*scratch*" (buffer-name))
        (progn (my:make-scratch 0) nil)
      t))

  ;; *scratch* バッファで kill-buffer したら内容を消去するだけにする
  (add-hook 'kill-buffer-query-functions #'my:clear-scratch-when-kill-buffer))

(defvar my:display-buffer-list-in-side-window nil)
(setq my:display-buffer-list-in-side-window
      `(((0 left) . ,(rx (or
                          "*completion*"
                          "*Help*"
                          "*Messages*"
                          ;; magit-staus系統はside window
                          "magit: "
                          )))
        ((0 bottom) . ,(rx (or
                            ;; deepl系統もside window
                            "*DeepL Translate*"
                            "*vterm*"
                            (regexp "[oO]utput\\*$"))))
        ((0 right) . ,(rx (or
                           ;; xref-referenceとかで分割されるのが結構ストレスなので
                           "*xref*"
                           )))
        ((1 left) . ,(rx (or
                          ;; commit messageはmagitと並ぶ格好にする
                          "COMMIT_EDITMSG")))))

(setq display-buffer-alist nil)

(seq-each (lambda (x)
            (let* ((config-slot (caar x))
                   (config-side (cadar x))
                   (config-buffer-regexp (cdr x)))
              (add-to-list 'display-buffer-alist
                           `(,config-buffer-regexp
                             (display-buffer-in-side-window)
                             (side . ,config-side)
                             (slot . ,config-slot)
                             (dedicated . t)
                             (window-width . 0.25)
                             (window-parameters . ((no-other-window . nil) ; disable because it makes me easier to switch window
                                                   (no-delete-other-windows . t)))))
              ))
          my:display-buffer-list-in-side-window)

(defcustom my:deepl-auth-key nil
  "Auth key for deepl"
  :group 'my
  :type '(string))

(defcustom my:deepl-api-host "api-free.deepl.com"
  "The host for deepl API. Use `api-free' when your plan is free."
  :type 'string
  :group 'my)

(defcustom my:deepl-send-confirmation-threshold 3000
  "Threshold of string before sending deepl"
  :type 'string
  :group 'my)

(eval-when-compile
  (straight-use-package 'request))

(setup *deepl
  (cl-defun my:deepl-send-string-confirm (&key retry)
    "Do confirmation before sending large string to deepl."
    (y-or-n-p (format "It's over %d characters, do you really want to send it" my:deepl-send-confirmation-threshold)))

  (cl-defun my:deepl-translate-internal (text source-lang target-lang callback)
    "Call deepl translate with confirmation."
    (when (and (> (length text) my:deepl-send-confirmation-threshold)
               (not (my:deepl-send-string-confirm)))
      (cl-return-from my:deel-translate-internal))

    (request (format "https://%s/v2/translate" my:deepl-api-host)
      :method "POST"
      :data `(
              ("auth_key" . ,my:deepl-auth-key)
              ("text" . ,text)
              ("source_lang" . ,source-lang)
              ("target_lang" . ,target-lang))
      :parser 'json-read
      :success callback))

  (cl-defun my:deepl-output-message (&key data &allow-other-keys)
    "Output and kill message with temporary buffer."
    (save-excursion
      (with-temp-buffer
        (rename-buffer "*DeepL Translate*")
        (switch-to-buffer (current-buffer))
        (let ((translated-text (cdr (assoc 'text (aref (cdr (assoc 'translations data)) 0)))))
          (insert translated-text)
          (when (y-or-n-p "Use this translation?")
            (kill-new translated-text))))))

  (defun my:japanese-character-p (char)
    (or (<= #x3041 char #x309f) ; hiragana
        (<= #x30a1 char #x30ff) ; katakana
        (<= #x4e01 char #x9faf) ; kanji
        ))

  (defun my:deepl-translate (start end)
    "Translate region via deepl."
    (interactive "r")
    (let ((region (buffer-substring-no-properties start end)))
      ;; 3文字以上日本語が含まれている場合は日本語と判断する。
      (if (>= (cl-count-if #'my:japanese-character-p region) 3)
          (my:deepl-translate-internal region "JA" "EN" #'my:deepl-output-message)
        (my:deepl-translate-internal region "EN" "JA" #'my:deepl-output-message))))
  )

(setup *font
       (:and window-system
             (add-hook 'after-init-hook #'my:font-initialize))
       
       (defun my:font-initialize (&optional font-size)
         "Initialize fonts on window-system"
         (interactive "P")

         (let ((emoji-font "Noto Color Emoji")
               (font-size (if font-size
                              (read-minibuffer "Font Size:")
                            my:font-size)))
           (when window-system
             (cond
              ((or (eq window-system 'x) (eq window-system 'pgtk) (eq window-system 'ns))
               (let* ((size (or font-size my:font-size))
                      (font-set-family my:font-family)
                      (h (round (* size 10))))
                 (when (member emoji-font (font-family-list))
                   (set-fontset-font t 'symbol (font-spec :family emoji-font) nil 'prepend))
                 (set-face-attribute 'default nil :family font-set-family :height h)))
              (t
               (message "Not have window-system")))))))

(setq redisplay-skip-fontification-on-input t)

(with-eval-after-load 'org
  (setup *for-init-org
    (defun my:tangle-init-org ()
      (when (or (string=
                 (expand-file-name "init.org" user-emacs-directory)
                 (buffer-file-name))
                (string=
                 (expand-file-name "early-init.org" user-emacs-directory)
                 (buffer-file-name)))
        (when-let* ((fname (file-name-base (buffer-file-name)))
                    (elc (seq-concatenate 'string fname ".elc"))
                    (byte-compiled-file (expand-file-name elc user-emacs-directory)))
          (when (file-exists-p byte-compiled-file)
            (delete-file byte-compiled-file)))
        
        (org-babel-tangle)))
    
    (:with-function my:tangle-init-org
      (:hook-into after-save-hook))
    )
  )

(setup modus-themes
  (:straight (modus-themes :type git :host github :repo "protesilaos/modus-themes"))

  (defun my:modus-mode-line-override ()
    "mode lineの表示が微妙だったので調整するhook"
    (let ((line (face-attribute 'mode-line :underline)))
      (set-face-attribute 'mode-line          nil :overline   line)
      (set-face-attribute 'mode-line-inactive nil :overline   line)
      (set-face-attribute 'mode-line-inactive nil :underline  line)
      (set-face-attribute 'mode-line          nil :box        nil)
      (set-face-attribute 'mode-line-inactive nil :box        nil))
    )
  
  (:when-loaded
    (setopt modus-themes-slanted-constructs t)
    (setopt modus-themes-bold-constructs t)
    (setopt modus-themes-mixed-fonts nil)
    (setopt modus-themes-variable-pitch-ui nil)
    
    (set-face-attribute 'modus-themes-completion-selected nil :inherit nil)

    ;; tab-barのstyleをmodusに適合するようにする
    (setq modus-themes-common-palette-overrides
          '((bg-tab-bar bg-main)
            (bg-tab-current bg-active)
            (bg-tab-other bg-inactive))))

  (defun my:load-modus-theme ()
    "modus-themeをloadするだけの関数"
    (load-theme 'modus-vivendi-tinted))

  (:with-function my:modus-mode-line-override
    (:hook-into modus-themes-post-load-hook))

  (:with-function my:load-modus-theme
    (:hook-into emacs-startup-hook))
  )

(setup transient
  (:straight (transient :type git :host github :repo "magit/transient" :branch "main"))
  (:require transient))

(setup *org-transient
  (with-eval-after-load 'transient
    (transient-define-prefix my:org-transient ()
      "Prefix for Org-mode related"
      [["Navigation"
        ("J" "Forward heading same level" org-forward-heading-same-level :transient t)
        ("K" "Backward heading same level" org-backward-heading-same-level :transient t)
        ("j" "Next heading" org-next-visible-heading :transient t)
        ("k" "Previous heading" org-previous-visible-heading :transient t)
        ("u" "Up level" outline-up-heading :transient t)
        ("l" "Change TODO state" org-cycle :transient t)
        ("h" "Org heading" consult-org-heading)
        ]
       ["Capture"
        ("c" "Capture" org-capture)
        ("r" "Org roam capture" org-roam-capture)
        ("d" "Done TODO" my:org-done-todo)
        ("n" "Toggle narrow subtree" org-toggle-narrow-to-subtree)
        ]
       ]
      )))

(setup *mark/replace-transient
  (with-eval-after-load 'transient
    (transient-define-prefix my:mark/replace-transient ()
      "The prefix for mark/replace related commands"
      [
       ["Rectangle"
        ("v" "Mark rectangle" rectangle-mark-mode)
        ("k" "Kill rectangle" kill-rectangle)
        ("y" "Copy rectangle" copy-rectangle-as-kill)
        ]
       ["Narrow/Widen"
        ("n" "Narrow to region" narrow-to-region)
        ("w" "Widen" widen)
        ]
       ["Replace"
        ("r" "Replace by visual" anzu-query-replace)
        ("t" "Replace thing at point by visual" anzu-query-replace-at-cursor-thing)
        ]
       ])))

(setup *navigation-transient
  (with-eval-after-load 'transient
    
    (transient-define-prefix my:navigation-transient ()
      "The prefix for navigation via consult and other commands."
      [
       ["Consult"
        ("b" "Buffer" consult-buffer)
        ("h" "Recentf" consult-recent-file)
        ("l" "Line" consult-line)
        ("o" "Outline" consult-outline)
        ("s" "Ripgrep" consult-ripgrep)
        ("F" "Search file by Fd" consult-fd)
        ("i" "Imenu list" consult-imenu)
        ]
       ["File and directory"
        ("e" "find file" find-file)
        ("d" "Dired jump" dired-jump)
        ("f" "Find file for project" project-find-file)
        ]
       ["Search by command"
        ("R" "Find by ripgrep" rg-menu)
        ]
       ])
    )
  )

(setup *persp-transient
  (:with-feature transient
    (:when-loaded
      (transient-define-prefix my:persp-transient ()
        "The prefix for persp command."
        [
         ["Buffer navigation"
          ("b" "Switch buffer" tabspaces-switch-to-buffer)
          ]
         ["Manage perspective"
          ("o" "Create and open perspective" tabspaces-open-or-create-project-and-workspace)
          ("k" "Kill perspective" tabspaces-close-workspace)
          ("r" "Rename perspective" tab-rename)
          ]
         ["Move between perspectives"
          ("s" "Switch perspective" tabspaces-switch-or-create-workspace)
          ("h" "Switch previous workspace" tab-previous)
          ("l" "Switch next workspace" tab-next)
          ]
         ])))
  )

(setup *project-transient
  (with-eval-after-load 'transient
    (transient-define-prefix my:project-transient ()
      "The prefix for project-related command"
      [
       ["Open/Select"
        ("o" "Open project" project-switch-project)
        ("D" "Forget project" project-forget-project)
        ("Z" "Forget zombie projects" project-forget-zombie-projects)]
       ["Find file/Search/Buffer"
        ("s" "Search project" consult-ripgrep)
        ("f" "Find file in project" consult-fd)
        ("b" "Switch to project buffer" project-switch-to-buffer)]])
    )
  )

(setup my:window-transient
  (:with-feature transient
    (:when-loaded
      (transient-define-prefix my:window-transient ()
        "Transient for window management"
        [
         ["Basic navigations"
          ("<return>" "Select window by key" ace-window)
          ("h" "Select left" windmove-left)
          ("j" "Select down" windmove-down)
          ("k" "Select up" windmove-up)
          ("l" "Select right" windmove-right)]
         ["Split window"
          ("s" "Split vertically" split-window-vertically)
          ("v" "Split horizontally" split-window-horizontally)
          ]
         ["Manipulate window"
          ("d" "Delete current window" delete-window)
          ("D" "Select and delete window" ace-delete-window)
          ("b" "Balance window" balance-windows)
          ("o" "Only current window" delete-other-windows)
          ("O" "Select and only the window" ace-delete-other-windows)]])))
  )

(setup *structuring-edit-transient
  (:with-feature transient
    (:when-loaded
      (transient-define-prefix my:structuring-transient ()
        "The prefix for structuring editing command"
        [
         ["Quit"
          ("q" "Quit" ignore)
          ("<escape>" "Quit" ignore)]
         ["Move with structuring"
          ("h" "backward char" backward-char :transient t)
          ("j" "Next sexp" puni-forward-sexp :transient t)
          ("k" "Previous sexp" puni-backward-sexp :transient t)
          ("l" "Forward char" forward-char :transient t)
          ("H" "Beginning of sexp" puni-beginning-of-sexp :transient t)
          ("L" "End of sexp" puni-end-of-sexp :transient t)
          ("," "Backward punct" puni-syntactic-backward-punct :transient t)
          ("." "Forward punct" puni-syntactic-forward-punct :transient t)
          ]
         ["Basic editing"
          ("D" "Kill line balanced" puni-kill-line :transient t)
          ("x" "Delete character force" (lambda () (interactive) (forward-char) (puni-force-delete)) :transient t)
          ("d" "Delete backward" puni-backward-delete-char :transient t)
          ("C-w" "Kill active region" puni-kill-active-region :transient t)
          ("u" "undo" undo :transient t)
          ("U" "redo" vundo :transient t)]
         ["Mark And yank"
          ("w" "mark and expand thing" my:treesit-expand-region :transient t)
          ("y" "yank" yank :transient t)]
         ["Useful editing"
          ("s" "Sqeeze" puni-squeeze :transient t)
          ("b" "Barf forward" puni-barf-forward :transient t)
          ("B" "Barf backward" puni-barf-backward :transient t)
          ("f" "Slurp forward" puni-slurp-forward :transient t)
          ("F" "Slurp backward" puni-slurp-backward :transient t)]
         ["Advanced editing"
          ("r" "Raise current exp" puni-raise :transient t)
          ("(" "Wrap with ())" puni-wrap-round :transient t)
          ("<" "Wrap with <>" puni-wrap-angle :transient t)
          ("[" "Wrap with []" puni-wrap-square :transient t)
          ("{" "Wrap with {}" puni-wrap-curly :transient t)
          ]])))
  )

(setup tab-bar
  (:hook-into emacs-startup-hook)

  (defvar my:tab-bar-format-function #'tab-bar-tab-name-format-default
    "formatting function to display tab name")

  (defvar my:tab-bar-face-function #'tab-bar-tab-face-default
    "Get face by tab")

  (defun my:tab-suffix ()
    "Empty suffix of tab."
    " ")

  (:when-loaded
    (setopt tab-bar-close-button-show nil)
    (setopt tab-bar-auto-width nil)

    (defface my:tab-bar-separator-face `((t (
                                             :weight light
                                             :height 1.2
                                             :background ,(face-attribute 'tab-bar-tab :background)
                                             :box (:line-width (12 . 8) :color nil :style flat-button)
                                             :inherit tab-bar
                                             )))
      "My tab separator face")
    (defvar my:tab-bar-separator (propertize "|" 'face 'my:tab-bar-separator-face)
      "separator of tab bar")

    ;; modus-themeに適合させつつ、modern-tab-barライクなstyleにする
    (set-face-attribute 'tab-bar nil
                        :box '(:line-width (12 . 8) :color nil :style flat-button)
                        :weight 'light)

    (defun my:tab-name-format-function (name tab i)
      "Tab nameの周辺にSpaceをいれるためのfunction"
      (let* ((tabs (tab-bar-tabs))
             (previous-tab (when (< 1 i)
                             (nth (- i 2) tabs)))
             (padding 8))
        (concat
         (cond
          ((and previous-tab
                (or (eq (car tab) 'current-tab)
                    (eq (car previous-tab) 'current-tab)))
           (propertize "|"
                       'face `(:inherit my:tab-bar-separator-face
                                        :foreground ,(face-attribute 'my:tab-bar-separator-face :background))
                       ))
          ((eq i 1)
           (propertize " "
                       'face 'my:tab-bar-separator-face
                       'display '((width 0)))
           )
          (t my:tab-bar-separator))
         (propertize " "
                     'display `((space :width (,padding)))
                     'face (funcall my:tab-bar-face-function tab))
         name
         (propertize " "
                     'display `((space :width (,padding)))
                     'face (funcall my:tab-bar-face-function tab))
         )))

    (setopt tab-bar-format '(tab-bar-format-tabs my:tab-suffix))
    ;; 末尾に追加することで、セパレーターを調整する
    (add-to-list 'tab-bar-tab-name-format-functions #'my:tab-name-format-function t)
    (setopt tab-bar-separator "")))

(setup tabspaces
  (:straight (tabspaces :type git :host github :repo "mclear-tools/tabspaces" :branch "main"))
  (:hook-into after-init-hook)
  (:when-loaded
    ;; tab ＝ Projectごとにfiltering されたbufferを利用する
    (setopt tabspaces-use-filtered-buffers-as-default t)
    ;; Defaultで使うタブ
    (setopt tabspaces-default-tab "Default")
    ;; Defaultで用意されるBufferを削除する
    (setopt tabspaces-remove-to-default t)
    ;; scratchは常に含まれるようにする
    (setopt tabspaces-include-buffers '("*scratch*"))

    ;; sessionを有効にする
    (setopt tabspaces-session t)
    (setopt tabspaces-session-auto-restore t)
    ))

(setup hide-mode-line
  (:straight hide-mode-line)
  (:hook-into imenu-list-major-mode-hook
              treemacs-mode-hook))

(setup moody
  (:straight moody)
  (:when-loaded
    ;; 実際にはFont sizeから導出する。
    (setopt moody-mode-line-height (let* ((font (face-font 'mode-line)))
                                     (if font
                                         (* 2 (aref (font-info font) 2))
                                       30))))
  (setopt x-underline-at-descent-line t))

(setup *my-mode-line
  (defgroup my:mode-line nil
    "Custom mode line."
    :group 'my)

  (defface my:buffer-position-active-face nil
    "Face for active buffer position indicator."
    :group 'my:mode-line)

  (defface my:mode-line:vc-icon-face nil
    "Face for vcs icon"
    :group 'my:mode-line)

  (defvar my:vc-status-text ""
    "Variable to store vc status text.")

  (setq my:mode-line-read-only-icon "  "
        my:mode-line-writable-icon "  "
        my:mode-line-modified-icon "  ")

  (defun my:mode-line-status ()
    "Return status icon for mode line status. This function uses nerd-icon package to get status icon."
    (let ((read-only (and buffer-file-name buffer-read-only))
          (modified (and buffer-file-name (buffer-modified-p))))

      (cond 
       (modified my:mode-line-modified-icon)
       (read-only my:mode-line-read-only-icon)
       (t my:mode-line-writable-icon))))

  (defun my:update-mode-line-vc-text ()
    "Update vcs text is used in mode-line"
    (setq my:vc-status-text
          (cond 
           ((and vc-mode buffer-file-name)
            (let* ((backend (vc-backend buffer-file-name))
                   (branch-name (if vc-display-status
                                    ;; 5 is skipped Gitx
                                    (substring vc-mode 5)
                                  ""))
                   (state (cl-case (vc-state buffer-file-name backend)
                            (added "  ")
                            (needs-merge "  ")
                            (needs-update "  ")
                            (removed "  ")
                            (t "  "))))
              (concat (propertize state 'face 'my:mode-line:vc-icon-face) branch-name)))
           (t ""))))
  ;; should update status text after refresh state
  (advice-add #'vc-refresh-state :after #'my:update-mode-line-vc-text)

  (defun my:mode-line-vc-state ()
    "Retrun status of current buffer."
    (when-let ((vc-status (my:update-mode-line-vc-text)))
      vc-status))

  (defun my:mode-line-buffer-position-percentage ()
    "Return current buffer position in percentage."
    (let ((pmax (point-max))
          (current (point)))
      (format "%d%%%%" (/ (* 100 current) pmax))))

  (defun my:mode-line-active-region-info ()
    "Return active region information if exists."
    (if (region-active-p)
        (let* ((region (car (region-bounds)))
               (lines (count-lines (car region) (cdr region)))
               (chars (seq-length (buffer-substring-no-properties (car region) (cdr region)))))
          (format " (L%d, C%d) " lines chars))
      " No region "))
  
  ;; definitions of mode-line elements
  (setq my:mode-line-element-buffer-status '(:eval (concat (my:mode-line-status)
                                                           )))
  (setq my:mode-line-element-major-mode '(:eval (concat " " (let ((name mode-name))
                                                              (cond
                                                               ((consp name) (car name))
                                                               (t name)))
                                                        " ")))
  (setq my:mode-line-element-vc-mode '(:eval (moody-ribbon (if vc-mode (my:mode-line-vc-state)
                                                             "No VCS"))))
  (setq my:mode-line-element-buffer-position '(:eval (moody-ribbon
                                                      (propertize
                                                       (my:mode-line-buffer-position-percentage)
                                                       'face 'my:buffer-position-active-face)
                                                      7)))
  (setq my:mode-line-element-pomodoro '(:eval (if (featurep 'simple-pomodoro)
                                                  (simple-pomodoro-mode-line-text)
                                                ""
                                                )))
  (setq my:mode-line-element-region '(:eval (my:mode-line-active-region-info)))

  (put 'my:mode-line-element-buffer-status 'risky-local-variable t)
  (put 'my:mode-line-element-major-mode 'risky-local-variable t)
  (put 'my:mode-line-element-vc-mode 'risky-local-variable t)
  (put 'my:mode-line-element-buffer-position 'risky-local-variable t)
  (put 'my:mode-line-element-pomodoro 'risky-local-variable t)
  (put 'my:mode-line-element-region 'risky-local-variable t)

  ;; define default mode line format
  (defun my:init-mode-line ()
    "Initialize mode line"
    (set-face-attribute 'my:buffer-position-active-face
                        nil
                        :inherit 'mode-line
                        :foreground (modus-themes-get-color-value 'red-warmer))

    (set-face-attribute 'my:mode-line:vc-icon-face
                        nil
                        :inherit 'mode-line
                        :foreground (modus-themes-get-color-value 'fg-alt))

    ;; replace mode line elements via moody
    (moody-replace-mode-line-front-space)
    (moody-replace-mode-line-buffer-identification)
    ;; macOSの場合は若干設定が異なる
    (when (eq system-type 'darwin)
      (setq moody-slant-function #'moody-slant-apple-rgb)
      )

    (setq-default mode-line-format
                  '("%e"
                    moody-mode-line-front-space
                    my:mode-line-element-buffer-status
                    moody-mode-line-buffer-identification
                    my:mode-line-element-region
                    mode-line-format-right-align
                    my:mode-line-element-pomodoro
                    my:mode-line-element-vc-mode
                    my:mode-line-element-buffer-position
                    my:mode-line-element-major-mode)))

  (:with-function my:update-mode-line-vc-text
    (:hook-into find-file-hook
                after-save-hook))
  (:with-feature modus-themes
    (:when-loaded
      (my:init-mode-line))))

(setup modalka
  (:straight modalka)

  (defun my:modalka-startup ()
    "modalkaをstartupしたら有効にするhook"
    (add-hook 'prog-mode-hook #'modalka-mode)
    (add-hook 'text-mode-hook #'modalka-mode))
  
  (:with-function my:modalka-startup
    (:hook-into after-init-hook))

  (defun my:modalka-mode-hook ()
    "modalka-mode用のhook"
    (when (not modalka-mode)
      (setq-local cursor-type 'bar))
    (if modalka-mode
        (selected-minor-mode +1)
      (selected-minor-mode -1)))
  (:hook my:modalka-mode-hook)

  ;; simple macro to make simple lambda with text obj
  (defmacro my:modalka (text-obj &rest keyword-args)
    "Get new lambda with `THEN-FUN' call after `BODY'

User can pass `KEYWORD-ARGS' below.

* `:then' - list of commands to execute AFTER `TEXT-OBJ'
* `:exit' - if non-nil, exit modelka-mode after executed
"
    (let ((then (plist-get keyword-args :then))
          (exit (plist-get keyword-args :exit)))
      `(lambda ()
         (interactive)
         ,(when exit
            '(modalka-mode -1))
         (progn ,@text-obj)
         ,@(when (and then (not (seq-empty-p then)))
             (seq-map (lambda (l) `(,l)) then))
         )))

  (defun my:modalka-setup ()
    "setup modalka-mode after-init"

    (modalka-define-kbd "1" "M-1")
    (modalka-define-kbd "2" "M-2")
    (modalka-define-kbd "3" "M-3")
    (modalka-define-kbd "4" "M-4")
    (modalka-define-kbd "5" "M-5")
    (modalka-define-kbd "6" "M-6")
    (modalka-define-kbd "7" "M-7")
    (modalka-define-kbd "8" "M-8")
    (modalka-define-kbd "9" "M-9")

    ;; global leader key
    (define-key modalka-mode-map (kbd "SPC")
                (let ((keymap (make-sparse-keymap)))
                  (define-key keymap "q" #'kill-current-buffer)
                  (define-key keymap "w" #'save-buffer)
                  (define-key keymap "e" #'find-file)
                  (define-key keymap "d" #'dired-jump)
                  (define-key keymap "m" #'magit-status)
                  (define-key keymap "b" #'ibuffer)
                  (define-key keymap "s" #'consult-ripgrep)
                  (define-key keymap "f" #'consult-fd)
                  (define-key keymap "#" #'server-edit)
                  (define-key keymap "v" #'vterm)
                  (define-key keymap "t" #'my:deepl-translate)
                  (define-key keymap "R" #'my:mark/replace-transient)
                  (define-key keymap "/" #'my:navigation-transient)
                  (define-key keymap "." #'my:persp-transient)
                  (define-key keymap "'" #'window-toggle-side-windows)

                  keymap
                  )
                )
    (define-key modalka-mode-map (kbd ",")
                (let ((keymap (make-sparse-keymap)))
                  (define-key keymap (kbd "o") #'my:org-transient)
                  (define-key keymap (kbd "p") #'my:project-transient)
                  keymap))

    (defun my:backward-symbol ()
      "my version backward-symbol"
      (interactive)
      (let ((point (bounds-of-thing-at-point 'symbol))
            (current (point)))
        (if (and point
                 (not (= (car point) current)))
            (goto-char (car point))
          (backward-word)))
      )

    (defun my:quit-window ()
      "quit-windowまたはwindowの切り替えを行うためのcomman"
      (interactive)
      (if (> (seq-length (window-list)) 1)
          (quit-window)
        (previous-buffer))
      )

    (defun my:forward-char-or-end-of-line ()
      "forward-char or end-of-line"
      (interactive)
      (unless (eolp)
        (forward-char)))

    (defun my:replace-char-at-point ()
      "vimのrコマンドのように、カーソル位置の文字を置換する"
      (interactive)
      (let ((now cursor-type))
        (setq-local cursor-type '(hbar . 3))
        (call-interactively #'quoted-insert)
        (setq-local cursor-type now))
      (forward-char 1)
      (delete-backward-char 1)
      (backward-char 1)
      )

    
    (define-key modalka-mode-map (kbd "<escape>") (my:modalka ((ignore)) :exit t))
    (define-key modalka-mode-map "q" #'my:quit-window)
    (define-key modalka-mode-map "z" #'recenter-top-bottom)
    ;; basic move
    (define-key modalka-mode-map "h" #'backward-char)
    (define-key modalka-mode-map "j" #'next-line)
    (define-key modalka-mode-map "k" #'previous-line)
    (define-key modalka-mode-map "l" #'forward-char)
    (define-key modalka-mode-map "E" #'forward-word)
    (define-key modalka-mode-map "B" #'backward-word)
    (define-key modalka-mode-map "e" #'forward-symbol)
    (define-key modalka-mode-map "b" #'my:backward-symbol)
    (define-key modalka-mode-map "$" #'end-of-line)
    (define-key modalka-mode-map "^" #'back-to-indentation)

    ;; advanced move
    (define-key modalka-mode-map "f" #'avy-goto-char)
    (define-key modalka-mode-map "X" #'goto-line)
    (define-key modalka-mode-map "g" #'keyboard-quit)
    (define-key modalka-mode-map "H" #'beginning-of-buffer)
    (define-key modalka-mode-map "G" #'end-of-buffer)
    
    ;; basic editing
    (define-key modalka-mode-map "a" (my:modalka ((my:forward-char-or-end-of-line)) :exit t))
    (define-key modalka-mode-map "A" (my:modalka ((end-of-line)) :exit t))
    (define-key modalka-mode-map "i" (my:modalka () :exit t))
    (define-key modalka-mode-map "I" (my:modalka ((back-to-indentation)) :exit t))
    (define-key modalka-mode-map "o" (my:modalka ((end-of-line) (newline-and-indent)) :exit t))
    (define-key modalka-mode-map "O" (my:modalka ((beginning-of-line) (newline-and-indent) (previous-line)) :exit t))
    (define-key modalka-mode-map "D" (my:modalka ((beginning-of-line) (kill-line))))
    (define-key modalka-mode-map "C" (my:modalka ((beginning-of-line) (kill-line)) :exit t))
    (define-key modalka-mode-map "J" #'delete-indentation)
    (define-key modalka-mode-map "x" (my:modalka ((forward-char) (puni-force-delete))))
    (define-key modalka-mode-map "r" #'my:replace-char-at-point)

    ;; advanced editing mode
    (define-key modalka-mode-map (kbd "R") #'my:structuring-transient)

    ;; yank/paste/mark
    (define-key modalka-mode-map "p" #'yank)
    (define-key modalka-mode-map "w" #'my:treesit-expand-region)
    (define-key modalka-mode-map "V" (my:modalka ((beginning-of-line) (set-mark (point)) (end-of-line))))
    (define-key modalka-mode-map "<" #'mc/mark-previous-like-this)
    (define-key modalka-mode-map ">" #'mc/mark-next-like-this)
    
    ;; basic search
    (define-key modalka-mode-map "/" #'isearch-forward)
    (define-key modalka-mode-map "n" #'isearch-repeat-forward)
    (define-key modalka-mode-map "N" #'isearch-repeat-backward)

    ;; undo/redo
    (define-key modalka-mode-map "u" #'undo)
    (define-key modalka-mode-map "U" #'vundo)

    ;; reverse mark
    (define-key modalka-mode-map "t" #'exchange-point-and-mark)
    ;; repeat
    (define-key modalka-mode-map "." #'repeat)

    ;; macro and insert counter
    ;; マクロを実際に動かすときは、Qで実行できる
    (define-key modalka-mode-map "@" #'kmacro-start-macro-or-insert-counter)
    (define-key modalka-mode-map "Q" #'kmacro-end-or-call-macro)

    ;; buffer
    (define-key modalka-mode-map ";" #'consult-project-buffer)
    
    ;; eval expression
    (define-key modalka-mode-map ":" #'eval-expression)

    ;; flymake integration
    (define-key modalka-mode-map (kbd "C-n") #'flymake-goto-next-error)
    (define-key modalka-mode-map (kbd "C-p") #'flymake-goto-prev-error)

    ;; window key map
    (define-key modalka-mode-map (kbd "C-w") #'my:window-transient)

    ;; mark and delete
    (defun my:mark-beginning-of-line-from-current ()
      "現在範囲から行頭までをmarkする。"
      (interactive)
      (set-mark (point))
      (beginning-of-line))

    (defun my:mark-end-of-line-from-current ()
      "現在範囲から行末までをmarkする。"
      (interactive)
      (set-mark (point))
      (end-of-line))

    (defun my:copy-line ()
      "行をcopyする。"
      (interactive)
      (save-excursion
        (beginning-of-line)
        (let* ((beg (point)))
          (end-of-line)
          (unless (eobp)
            (forward-char))
          (copy-region-as-kill beg (point)))))

    (defun my:copy-end-of-line ()
      "行末までをcopyする"
      (interactive)
      (save-excursion
        (let ((beg (point)))
          (end-of-line)
          (copy-region-as-kill beg (point)))))

    ;; delete/mark/change with prefix
    (define-key modalka-mode-map (kbd "y y") #'my:copy-line)
    (define-key modalka-mode-map (kbd "y $") #'my:copy-end-of-line)
    (define-key modalka-mode-map (kbd "d d") (lambda () (interactive)
                                               (beginning-of-line)
                                               (set-mark (point))
                                               (end-of-line)
                                               (forward-char)
                                               (puni-kill-active-region)
                                               ))
    (define-key modalka-mode-map (kbd "d e") (lambda () (interactive)
                                               (puni-mark-sexp-at-point)
                                               (puni-kill-active-region)))
    (define-key modalka-mode-map (kbd "d E") (lambda () (interactive)
                                               (mark-word)
                                               (puni-kill-active-region)))
    (define-key modalka-mode-map (kbd "d a") (lambda () (interactive)
                                               (puni-mark-sexp-around-point)
                                               (puni-kill-active-region)))
    (define-key modalka-mode-map (kbd "d ^") (lambda () (interactive)
                                               (my:mark-beginning-of-line-from-current)
                                               (puni-kill-active-region)))
    (define-key modalka-mode-map (kbd "d $") (lambda () (interactive)
                                               (my:mark-end-of-line-from-current)
                                               (puni-kill-active-region)))
    (define-key modalka-mode-map (kbd "v e") #'puni-mark-sexp-at-point)
    (define-key modalka-mode-map (kbd "v E") #'mark-word)
    (define-key modalka-mode-map (kbd "v a") #'puni-mark-sexp-around-point)
    (define-key modalka-mode-map (kbd "v ^") #'my:mark-beginning-of-line-from-current)
    (define-key modalka-mode-map (kbd "v $") #'my:mark-end-of-line-from-current)

    ;; change
    (define-key modalka-mode-map (kbd "c e") (my:modalka ((puni-mark-sexp-at-point) (puni-kill-active-region)) :exit t))
    (define-key modalka-mode-map (kbd "c E") (my:modalka ((mark-word) (puni-kill-active-region)) :exit t))
    (define-key modalka-mode-map (kbd "c a") (my:modalka ((puni-mark-sexp-around-point) (puni-kill-active-region)) :exit t))
    (define-key modalka-mode-map (kbd "c ^") (my:modalka ((my:mark-beginning-of-line-from-current)) :then (puni-kill-active-region) :exit t))
    (define-key modalka-mode-map (kbd "c $") (my:modalka ((my:mark-end-of-line-from-current)) :then (puni-kill-active-region) :exit t))
    )
  
  (:with-hook emacs-startup-hook
    (:hook my:modalka-setup))
  )

(setup with-editor
  (:straight with-editor))

(setup compat
  (:straight compat))

(setup magit
  (:straight (magit :type git :host github :repo "magit/magit"))
  (:when-loaded
    ;; magitのbuffer切り替えを変える
    (setopt magit-display-buffer-function #'display-buffer))
  
  (with-eval-after-load 'compat
    (defun my:insert-commit-template-on-magit ()
      "Insert commit comment template after opened commit buffer on magit."
      (tempel-insert 'cc))

    (defun my:git-post-commit--delete-EDITMSG ()
      "EDITMSGを削除する"
      (when-let* ((target-name "COMMIT_EDITMSG")
                  (buffer (seq-find (lambda (buf)
                                      (let ((name (buffer-name buf)))
                                        (string-match-p name target-name)))
                                    (buffer-list))))
        (condition-case err
            (kill-buffer buffer)
          nil
          )))
    (defun my:disable-modalka-on-commit ()
      "commitではmodalを無効化する"
      (when (featurep 'modalka)
        (modalka-mode -1)))

    (:with-hook git-commit-post-finish-hook
      (:hook my:git-post-commit--delete-EDITMSG))
    (:with-hook git-commit-mode-hook
      (:hook my:insert-commit-template-on-magit
             my:disable-modalka-on-commit))
    )
  )

(setup magit-delta
  (:straight magit-delta)
  (:with-feature magit
    (:hook magit-delta-mode)))

(setup consult
  (:straight consult)
  
  (defun my:consult-search-dwim (&optional prefix)
    "Merge version to search document via grep/rg.
     Use fast alternative if it exists, fallback grep if no alternatives in system.
    "
    (interactive "P")
    (cond
     ((executable-find "rg") (consult-ripgrep prefix))
     (t (consult-grep prefix))))

  ;; hotfuzz-moduleが有効な場合は、この設定がないとconsultでの検索がerrorになる場合がある
  (setq consult--tofu-char #x100000)
  (setq consult--tofu-range #x00fffe)

  ;; recent fileでpreviewする場合は明示的に実行する
  (:when-loaded
    (setopt consult-fd-args '((if (executable-find "fdfind" 'remote) "fdfind" "fd") "--full-path --color=never -H"))
    (setopt consult-ripgrep-args
            "rg --null --line-buffered --color=never --max-columns=1000 --path-separator / --smart-case --no-heading --with-filename --line-number --hidden")

    ;; previewはC-.を押したときだけ
    (setopt consult-preview-key "C-.")))

(setup embark
  (:straight embark)
  (:global
   (kbd "M-a") embark-act
   (kbd "<f1> B") embark-bindings))

(setup embark-consult
  (:straight embark-consult)
  (:with-mode embark-consult-preview-minor-mode
    (:hook-into embark-collect-mode-hook)))

(setup marginalia
  (:straight marginalia)
  ;; Either bind `marginalia-cycle` globally or only in the minibuffer
  (:with-map minibuffer-local-map
    (:bind
     (kbd "M-A") marginalia-cycle
     )
    )
  (:autoload-this)
  (:when-loaded
    (add-to-list 'marginalia-prompt-categories
                 '("\\<File\\>" . file))
    )
  (marginalia-mode +1))

(setup vertico
  (:straight (vertico :type git :host github :repo "minad/vertico"))
  (:hook-into emacs-startup-hook)

  ;; 選択時にprefix iconを表示する
  ;; https://github.com/minad/vertico/wiki#prefix-current-candidate-with-arrow
  (defvar +vertico-current-arrow t)

  (cl-defmethod vertico--format-candidate :around
    (cand prefix suffix index start &context ((and +vertico-current-arrow
                                                   (not (bound-and-true-p vertico-flat-mode)))
                                              (eql t)))
    (setq cand (cl-call-next-method cand prefix suffix index start))
    (let ((arrow (nerd-icons-faicon "nf-fa-hand_o_right")))
      (if (bound-and-true-p vertico-grid-mode)
          (if (= vertico--index index)
              (concat " " arrow " " cand)
            (concat #("_" 0 1 (display " ")) cand))
        (if (= vertico--index index)
            (concat " " arrow " " cand)
          (concat "    " cand)))))

  (:when-loaded
    ;; 最大20件まで表示するように
    (setopt vertico-count 20)

    ;; vertico内でdirectory 移動を効率的に行うことができるようにする
    (setup vertico-directory
      (:require vertico-directory)
      (:with-map vertico-map
        (:bind
         (kbd "RET") vertico-directory-enter
         (kbd "<backspace>") vertico-directory-delete-char
         (kbd "M-DEL") vertico-directory-delete-word
         ))
      )
    ;; minibufではなく標準のバッファで表示する
    (vertico-buffer-mode +1)

    ;; bufferは分割の方向が混乱してしまうときが結構あるので、bottom固定とする
    ;; side window設定もできるのだが、そうしてしまうと、window の中身がずれてしまってかなりストレスだったので、
    ;; 通常のwindow にしている
    (setopt vertico-buffer-display-action `(display-buffer-at-bottom
                                            (window-height . ,(+ 3 vertico-count))))
    
    (vertico-multiform-mode +1)
    (add-to-list 'vertico-multiform-categories '(jinx grid (vertico-grid-annotate . 20)))
    )
  )

(setup *orderless-migemo-config
  (with-eval-after-load 'migemo
    
    ;; from https://nyoho.jp/diary/?date=20210615
    (defun my:orderless-migemo (component)
      (let ((pattern (migemo-get-pattern component)))
        (condition-case nil
            (progn (string-match-p pattern "") pattern)
          (invalid-regexp nil))))

    (orderless-define-completion-style orderless-default-style
      (orderless-matching-styles '(orderless-literal
                                   orderless-regexp)))

    (orderless-define-completion-style orderless-migemo-style
      (orderless-matching-styles '(orderless-literal
                                   orderless-regexp
                                   my:orderless-migemo)))

    (setq completion-category-overrides
          '((command (styles orderless-default-style))
            ;; ファイルの場合には、pathの部分matchをするように
            (file (styles orderless-migemo-style))
            (org-roam-node (styles . (partial-completion orderless-migemo-style)))
            (buffer (styles orderless-migemo-style))
            (symbol (styles orderless-default-style))
            (consult-location (styles orderless-migemo-style)) ; category `consult-location' は `consult-line' などに使われる
            (consult-multi (styles orderless-migemo-style)) ; category `consult-multi' は `consult-buffer' などに使われる
            (unicode-name (styles orderless-migemo-style))
            (variable (styles orderless-default-style))))))

(setup orderless
  (:straight orderless)
  (:require orderless))

(setup hotfuzz
  (:straight (hotfuzz :type git :host github :repo "axelf4/hotfuzz" :branch "master"
                      :files ("hotfuzz.el" "hotfuzz-module.c" "CMakeLists.txt")))

  (add-to-list 'completion-styles 'hotfuzz))

(setup corfu
  (:straight (corfu :type git :host github :repo "minad/corfu" :branch "main"))

  

  (:with-mode global-corfu-mode
    (:hook-into emacs-startup-hook))

  (:when-loaded
    (setopt corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
    (setopt corfu-auto t)                 ;; Enable auto completion
    (setopt corfu-auto-delay 0.1)                 ;; 即時表示を試してみる
    (setopt corfu-count 15)                        ;; show more candidates
    (setopt corfu-auto-prefix 2)
    (setopt corfu-max-width 300)               ;; max width of corfu completion UI
    (setopt corfu-on-exact-match nil)          ; 単独で厳密マッチしたものがあった場合の挙動。一旦何もしない。
    (setopt corfu-preselect 'prompt)           ;最初の候補を選択しない
    
    (defvar corfu--index)
    (defvar corfu-magic-insert-or-next-line
      `(menu-item "" nil :filter ,(lambda (&optional _)
                                    (when (>= corfu--index 0)
                                      'corfu-insert)))
      "If we made a selection during `corfu' completion, select it.")
    (define-key corfu-map (kbd "RET") corfu-magic-insert-or-next-line)

    (defvar corfu-magic-cancel-or-backspace
      `(menu-item "" nil :filter ,(lambda (&optional _)
                                    (when (>= corfu--index 0)
                                      'corfu-reset)))
      "If we made a selection during `corfu' completion, cancel it.")
    (define-key corfu-map (kbd "DEL") corfu-magic-cancel-or-backspace)
    (define-key corfu-map (kbd "<backspace") corfu-magic-cancel-or-backspace)
    )
  
  (setup corfu-popupinfo
    (:hook-into corfu-mode-hook)))

(setup cape
  (:straight cape)
  (:with-feature eglot
    (:with-hook eglot-managed-mode-hook
      (:hook my:eglot-capf)))
  
  (defun my:eglot-capf ()
    "set capf for eglot"
    (setq-local completion-at-point-functions
                (list (cape-capf-case-fold
                       (cape-capf-super
                        #'eglot-completion-at-point
                        #'tempel-complete
                        #'cape-file)))))

  ;; Add `completion-at-point-functions', used by `completion-at-point'.
  (add-to-list 'completion-at-point-functions #'tempel-complete)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-keyword))

(setup org
  (:straight org)
  (:when-loaded
    ;; org-mode内部のソースを色付けする
    (setopt org-src-fontify-natively t)
    ;; org-modeの開始時に、行の折り返しを無効にする。
    (setopt org-startup-truncated t)
    ;; follow-linkから戻ることを可能とする。
    (setopt org-return-follows-link t)
    ;; 自動的にタグをalignしない
    (setopt org-auto-align-tags nil)
    ;; tagをalign するカラム
    (setopt org-tags-column 0)
    (setopt org-catch-invisible-edits 'show-and-error)
    ;; 先頭にあるstarを隠す
    (setopt org-hide-leading-stars t)
    ;; org特有のCtrl-a/eの挙動を使う
    (setopt org-special-ctrl-a/e t)
    ;; 現在のsubtreeの後にheadingを追加するようにする
    (setopt org-insert-heading-respect-content t)

    ;; UTF8にあるentitiesを利用するようにする
    (setopt org-pretty-entities t)
    ;; outlineのellipsisで使う文字を指定する
    (setopt org-ellipsis "…")
    ;; refileするときにfileを使う
    (setopt org-refile-use-outline-path 'file)
    (setopt org-outline-path-complete-in-steps nil)
    ;; doneしたら時刻を記録する
    (setopt org-log-done 'time)
    ;; TODOにおける区別
    (setopt org-todo-keywords '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)" "CANCELED(c)")))

    ;; nodeのLevel に応じたインデントは行わない
    (setopt org-adapt-indentation nil)
    ;; <の後で使えるテンプレート
    (setopt org-structure-template-alist '(("s" . "src")
                                           ("e" . "example")
                                           ("c" . "center")
                                           ("q" . "quote")
                                           ("v" . "verse")
                                           ("C" . "comment")
                                           ("E" . "export")
                                           ("l" . "src emacs-lisp")
                                           ("h" . "export html")
                                           ("a" . "export ascii")))))

(setup ob-plantuml
  (:with-feature org
    (:when-loaded
      (org-babel-do-load-languages 'org-babel-load-languages '((plantuml . t)))
      
      (setq org-plantuml-jar-path (expand-file-name (locate-user-emacs-file "plantuml.jar"))))))

(setup *org-local-functions
  (:with-function my:org-roam-project-update-tag
    (:hook-into after-save-hook))
  
  (defun my:org-capture ()
    "do capture fastest"
    (interactive)
    (org-capture nil "t"))

  (defun my:org-done-todo ()
    (interactive)
    (org-todo "DONE"))

  (defun my:org-current-is-todo ()
    (string= "TODO" (org-get-todo-state)))

  (defun my:org-roam-buffer-p (&optional buffer)
    "Return boolean that current buffer is roam buffer or not"
    (with-current-buffer (or buffer (current-buffer))
      (and buffer-file-name
           (string= (expand-file-name (file-name-as-directory my:org-roam-directory))
                    (expand-file-name (file-name-directory buffer-file-name))))))

  (defun my:org-roam-project-file-p (&optional buffer)
    "Return non-nil if current buffer has any todo entry"
    (org-element-map
        (org-element-parse-buffer 'headline)
        'headline
      (lambda (e) (eq (org-element-property :todo-type e) 'todo))
      nil 'first-match))

  (defun my:org-roam-update-roam-tags (&rest tags)
    "Update filetags with TAGS list"
    (let* ((tags (combine-and-quote-strings tags " ")))
      (my:org-set-keyword "filetags" tags)))

  (defun my:org-roam-project-update-tag ()
    "Update PROJECT tag in the current buffer."
    (when (and (not (active-minibuffer-window))
               (my:org-roam-buffer-p))
      (save-excursion
        (goto-char (point-min))
        (let* ((tags (or (my:org-get-keyword "filetags") ""))
               (tags (--map (s-replace-all '(("\"" . "")) it) (s-split " " tags)))
               (original-tags tags))
          (if (my:org-roam-project-file-p)
              (setq tags (seq-uniq (cons "project" tags)))
            (setq tags (remove "project" tags)))
          (unless (equal original-tags tags)
            (apply #'my:org-roam-update-roam-tags tags))))))

  (defun my:org-roam-project-files ()
    "Return a list of note files containing 'project' tag." ;
    (seq-uniq
     (seq-map
      #'car
      (org-roam-db-query
       [:select [nodes:file]
                :from tags
                :left-join nodes
                :on (= tags:node-id nodes:id)
                :where (like tag (quote "%\"project\"%"))]))))


  (defun my:org-set-keyword (keyword value &optional buffer)
    "Add or replace VALUE of KEYWORD of org-mode to current buffer. "
    (save-excursion
      (with-current-buffer (or buffer (current-buffer))
        (let* ((org-tree (org-element-parse-buffer))
               (el (org-element-map
                       org-tree
                       'keyword
                     (lambda (el) (let ((keyword-in-el (org-element-property :key el)))
                                    (and (string-match-p keyword keyword-in-el)
                                         el)))
                     nil 'first-match)))
          (when el
            (delete-region (org-element-property :begin el) (org-element-property :end el))
            (setq org-tree (org-element-parse-buffer)))

          (let* ((first-keyword (org-element-map org-tree 'keyword #'identity nil t))
                 (el (if (not el)
                         (let* ((el (org-element-create 'keyword))
                                (el (org-element-put-property el :key keyword))
                                (el (org-element-put-property el :value value)))
                           (goto-char (1+ (org-element-property :end first-keyword)))
                           (newline)
                           (insert (org-element-interpret-data el)))
                       (org-element-put-property el :value value))))

            (goto-char (org-element-property :end first-keyword))
            (insert (org-element-interpret-data el))
            (save-buffer))))))

  (defun my:org-get-keyword (keyword &optional buffer)
    "Get KEYWORD from BUFFER or current buffer. You can use regexp or raw string for KEYWORD."
    (with-current-buffer (or buffer (current-buffer))
      (let ((el (org-element-map
                    (org-element-parse-buffer)
                    'keyword
                  (lambda (el)
                    (when (string-match-p (s-upcase keyword) (org-element-property :key el)) el)) nil 'first-match)))
        (when el
          (org-element-property :value el)))))

  (defun my:org-global-props (&optional property buffer)
    "Get the plists of global org properties of current buffer."
    (unless property (setq property "PROPERTY"))
    (with-current-buffer (or buffer (current-buffer))
      (org-element-map
          (org-element-parse-buffer)
          'keyword
        (lambda (el) (when (string-match property (org-element-property :key el)) el)))))

  (defun my:org-add-ymd-to-archive (name)
    "replace anchor to YYYY-MM string"
    (let* ((ymd (format-time-string "%Y-%m")))
      (replace-regexp-in-string "#YM" ymd name)))

  (:with-feature org
    (:when-loaded
      (advice-add 'org-extract-archive-file :filter-return #'my:org-add-ymd-to-archive))))

;; refileする対象を指定する
(setup *refile-settings
  (:with-feature org
    (:when-loaded
      (let ((project (expand-file-name "project.org" my:org-roam-directory)))
        (setq org-refile-targets
              `((,project :maxlevel . 1)))))))

;; archiveするときの設定
(setup *archive-settings
  (:with-feature org
    (:when-loaded
      (:and my:org-roam-directory
            (progn
              (let ((inbox (expand-file-name "inbox.org" my:org-roam-directory)))
                (setq org-capture-templates
                      `(("t" "todo" plain (file ,inbox)
                         "* TODO %?\n%U\n" :clock-resume t))))

              (defun my:org-set-archive-name-for-month (&rest args)
                (setq-local org-archive-location (concat "./archives/"
                                                         (format-time-string "%Y%m" (current-time))
                                                         "-%s_archive::datetree/* Finished Tasks")))

              (advice-add 'org-archive-subtree :before #'my:org-set-archive-name-for-month))))))

(setup org-agenda
  (:and my:org-roam-directory)
  (:global
   (kbd "C-c a")  org-agenda)
  (:when-loaded
    ;; Agendaで使える拡張コマンド
    (setopt org-agenda-custom-commands '((" " "Agenda"
                                          ((tags
                                            "REFILE"
                                            ((org-agenda-overriding-header "To refile")
                                             (org-tags-match-list-sublevels nil)))
                                           (tags
                                            "PROJECT"
                                            ((org-agenda-overriding-header "To project")
                                             (org-tags-match-list-sublevels nil)))))))
    ;; 現時点を示す文字列
    (setopt org-agenda-current-time-string "  now")
    ;; 時間をくぎる文字列
    (setopt org-agenda-time-grid '((daily today require-timed)
                                   (0700 0800 0900 01000 1100 1200 1300 1400 1500 1600 1700 1800 1900 2000 2100 2200 2300 2400)
                                   "-"
                                   "────────────────"))
    ;; それぞれのprefix
    (setopt org-agenda-prefix-format '((agenda . " %i %-15(my:org-agenda-category 15)%?-12t%s")
                                       (todo . " %i %-15(my:org-agenda-category 15) ")
                                       (tags . " %i %-15(my:org-agenda-category 15) ")
                                       (search . " %i %-15(my:org-agenda-category 15) ")))

    ;; clockreportの内容
    (setopt org-agenda-clockreport-parameter-plist '(
                                                     :maxlevel 5
                                                     :block t
                                                     :tstart t
                                                     :tend t
                                                     :emphasize t
                                                     :link t
                                                     :narrow 80
                                                     :indent t
                                                     :formula nil
                                                     :level 5
                                                     :tcolumns nil
                                                     :properties ("CATEGORY")
                                                     :hidefiles t)))

  (:when-loaded
    (defun my:org-agenda-files-update (&rest _)
      "Update the value of `org-agenda-files'."
      (setq org-agenda-files (my:org-roam-project-files))
      (add-to-list 'org-agenda-files (expand-file-name "inbox.org" my:org-roam-directory)))

    (advice-add 'org-agenda :before #'my:org-agenda-files-update)
    
    (defun my:org-agenda-category (&optional len)
      "Get category of item at point for agenda.

Category is defined by one of the following items:

- CATEGORY property
- TITLE keyword
- TITLE property
- filename without directory and extension

When LEN is a number, resulting string is padded right with
spaces and then truncated with ... on the right if result is
longer than LEN.

Usage example:

  (setq org-agenda-prefix-format
        '((agenda . \" %(my:org-agenda-category) %?-12t %12s\")))

Refer to `org-agenda-prefix-format' for more information."
      (let* ((file-name (when buffer-file-name
                          (file-name-sans-extension
                           (file-name-nondirectory buffer-file-name))))
             (title (my:org-get-keyword "title"))
             (category (org-get-category))
             (result
              (or (if (and
                       title
                       (string-equal category file-name))
                      title
                    category)
                  "")))
        (if (numberp len)
            (s-truncate len (s-pad-right len " " result))
          result)))))

(setup org-clock
  (:with-hook org-clock-out-hook
    (:hook org-update-all-dblocks))
  (:when-loaded
    ;; 0秒は記録しない
    (setopt org-clock-out-remove-zero-time-clocks t)
    ;; frameのtitleに経過時間を表示する
    (setopt org-clock-clocked-in-display 'frame-title)
    (setopt org-clock-frame-title-format '((:eval (format "%s %s"
                                                          (if (require 'org-clock-today nil t)
                                                              (if org-clock-today-count-subtree
                                                                  (format "%s / %s"
                                                                          org-clock-today-subtree-time
                                                                          org-clock-today-buffer-time)
                                                                (format "%s" org-clock-today-buffer-time))
                                                            "")
                                                          org-mode-line-string))))
    (:with-function my:org-clock-out-and-save-when-exit
      (:hook-into kill-emacs-hook)))

  (defvar my:org-clocked-time-mode-line ""
    "org-clock-inしているときのmode line")
  
  (defun my:org-clock-out-and-save-when-exit ()
    "Save buffers and stop clocking when kill emacs."
    (when (org-clocking-p)
      (org-clock-out)
      (save-some-buffers t)))
  
  (defun my:task-clocked-time ()
    (interactive)
    (let* ((clocked-time (org-clock-get-clocked-time))
           (h (truncate clocked-time 60))
           (m (mod clocked-time 60))
           (work-done-str (format "%d:%02d" h m)))
      (if org-clock-effort
          (let* ((effort-in-minutes
                  (org-duration-to-minutes org-clock-effort))
                 (effort-h (truncate effort-in-minutes 60))
                 (effort-m (truncate (mod effort-in-minutes 60)))
                 (effort-str (format "%d:%02d" effort-h effort-m)))
            (format "%s/%s" work-done-str effort-str))
        (format "%s" work-done-str))))

  (defun my:update-task-clocked-time ()
    (setq my:org-clocked-time-mode-line (my:task-clocked-time))))

(setup ox-hugo
  (:straight ox-hugo)
  (:with-hook org-mode-hook
    (:hook my:org-hugo-enable-if-hugo-buffer))
  
  (defun my:org-hugo-enable-if-hugo-buffer ()
    (let ((prop (my:org-global-props "HUGO_.\+" (current-buffer))))
      (when prop
        (org-hugo-auto-export-mode +1)))))

(setup org-onit
  (:straight (org-onit :type git :host github :repo "takaxp/org-onit"))
  (:global
   (kbd "C-<f11>") org-clock-goto)
  (:with-feature org
    (:with-map org-mode-map
      (:bind
       (kbd "<f11>")  org-onit-toggle-doing
       (kbd "S-<f11>") org-onit-goto-anchor))))

(setup org-tempo
  (:with-feature org
    (:when-loaded
      (:require org-tempo))))

(setup org-roam
  (:only-if (file-exists-p my:org-roam-directory))
  (:straight (org-roam :type git :host github :repo "org-roam/org-roam"))

  (:when-loaded
    (setq org-roam-directory my:org-roam-directory)
    (setopt org-roam-db-update-on-save t)
    (setopt org-roam-db-location my:org-roam-db-location)
    (setopt org-roam-database-connector 'sqlite-builtin)
    (setopt org-roam-capture-ref-templates '(("r" "ref" plain "%?"
                                              :if-new (file+head "%<%Y-%m-%d--%H-%M-%SZ>--${slug}.org" "#+title: ${title}\n#+filetags: \n#+roam_key: ${ref}")
                                              :unnarrowed t)))
    (setopt org-roam-capture-templates '(("d" "default" plain
                                          "%?"
                                          :if-new (file+head "%<%Y-%m-%d--%H-%M-%SZ>--${slug}.org" "#+title: ${title}\n#+filetags: \n")
                                          :unnarrowed t))))
  (:with-feature org
    (:with-map org-mode-map
      (:bind
       (kbd "C-c r") org-roam-node-insert
       (kbd "C-c t") org-roam-tag-add)))
  (:with-function org-roam-db-autosync-mode
    (:hook-into emacs-startup-hook)
    ))

(setup emacsql-sqlite-builtin
  (:straight emacsql-sqlite-builtin))

(setup org-modern
  (:straight org-modern)
  (:when-loaded
    (setopt org-modern-block-fringe t)
    ;; UDEV Gothicだとガタつくので、ガタつかないのと視覚的にわかりやすいものを使う
    (setopt org-modern-star 'replace)
    (setopt org-modern-replace-stars "①②③④⑤")
    (setopt org-modern-hide-stars nil))

  (:with-feature org
    (:hook org-modern-mode)))

(setup go-mode
  (:straight go-mode)
  (:bind
   "M-." godef-jump)
  (:hook my:go-mode-hook-1)

  ;; go.modがある場所をrootとする
  (defun my:project-find-go-module (dir)
    (when-let ((root (locate-dominating-file dir "go.mod")))
      (cons 'go-module root)))

  (cl-defmethod project-root ((project (head go-module)))
    (cdr project))

  (defun my:go-mode-hook-1 ()
    ;; そのバッファでのみ有効にする
    (add-hook 'project-find-functions #'my:project-find-go-module 0 t)

    (eglot-ensure)))

(setup lisp-mode
  (defun my:lisp-mode-hook-0 ())
  (:hook my:lisp-mode-hook-0))

(setup *roswell
  (:and (let ((helper (expand-file-name "helper.el" my:roswell-path)))
          (and (file-exists-p helper) my:roswell-path))
        (progn
          (defvar roswell-slime-contribs '(slime slime-fancy))
          (load helper)

          (defun slime-qlot-exec (directory)
            "start slime with qlot"
            (slime-start :program "qlot"
                         :program-args '("exec" "ros" "-S" "." "run")
                         :directory directory
                         :name 'qlot
                         :env (list (concat "PATH="
                                            (mapconcat 'identity exec-path ":"))
                                    (concat "QUICKLISP_HOME="
                                            (file-name-as-directory directory) "quicklisp/"))))

          (defun slime-qlot (directory)
            "start slime with qlot"
            (interactive (list (read-directory-name "Project directory: ")))
            (slime-qlot-exec directory))

          (defun slime-qlot-restart (directory)
            (interactive (list (read-directory-name "Project directory: ")))
            (ignore-errors
              (let* ((buffer (get-buffer "*inferior-lisp*"))
                     (process (get-buffer-process buffer)))
                (when (and buffer process)
                  (set-process-query-on-exit-flag process nil)
                  (kill-buffer buffer))))
            (slime-qlot-exec directory))
          )
        ))

(setup hyperspec
  (:if-feature slime)
  ;; HyperSpecをewwで見る設定
  (setq common-lisp-hyperspec-root "~/.emacs.d/share/HyperSpec/")

  (unless (file-exists-p (expand-file-name "~/.emacs.d/share/HyperSpec"))
    (when (eq window-system 'x)

      (make-directory (expand-file-name "~/.emacs.d/share") t)
      (let ((hyperspec-url "ftp://ftp.lispworks.com/pub/software_tools/reference/HyperSpec-7-0.tar.gz")
            (output "/tmp/HyperSpec.tar.gz"))

        (call-process "curl" nil nil t "-L" "-o" output hyperspec-url)
        (shell-command (format "tar zxvf %s -C %s" output "~/.emacs.d/share")))))

  ;; redefine function
  (defun common-lisp-hyperspec (symbol-name)
    (interactive (list (common-lisp-hyperspec-read-symbol-name)))
    (let ((buf (current-buffer)))
      (let ((name (common-lisp-hyperspec--strip-cl-package
                   (downcase symbol-name))))
        (cl-maplist (lambda (entry)
                      (eww-open-file (concat common-lisp-hyperspec-root "Body/"
                                             (car entry)))
                      (when (cdr entry)
                        (sleep-for 1.5)))
                    (or (common-lisp-hyperspec--find name)
                        (error "The symbol `%s' is not defined in Common Lisp"
                               symbol-name))))
      (switch-to-buffer buf)
      (display-buffer "*eww*"))))

(setup ruby-mode
  (:file-match "\\.rb\\'")
  (:hook ruby-end-mode)
  (:bind
   "C-c x" xmp))

(setup ruby-end
  (:straight ruby-end))

(setup rust-mode
  (:and (version< emacs-version "29")
        (:straight rust-mode)
        )
  (:when-loaded
    (setopt rust-indent-offset 4)
    ;; formatterはcommit時にのみ実行するようにした方がよいので、機能をオフにする
    (setopt rust-format-on-save nil))

  (:hook eglot-ensure
         cargo-minor-mode))

(setup rust-ts-mode
  (:and (version< "29" emacs-version)
        (:require rust-ts-mode))
  (:hook my:rust-mode-hook
         cargo-minor-mode)
  (:when-loaded
    (setopt rust-ts-indent-offset 4))
  
  (defun my:find-rust-project-root (dir)
    (when-let ((root (locate-dominating-file dir "Cargo.lock")))
      (list 'vc 'Git root)))

  (defun my:rust-mode-hook ()
    (setq-local project-find-functions (list #'my:find-rust-project-root))
    (eglot-ensure)))

(setup cargo
  (:straight cargo))

(setup python
  (:file-match "\\.py\\'")
  (:hook my:python-mode-hook-0)
  (defun my:python-mode-hook-0 ()
    (setq-local indent-tabs-mode nil)
    (pyvenv-mode +1)))

(setup pyvenv
  (:and  my:virtualenv-path
         (file-exists-p my:virtualenv-path)
         (:straight pyvenv))
  
  (defun my:pyvenv-activate-hook ()
    "pyvenvを有効にする"
    (pyvenv-activate my:virtualenv-path))
  (:with-function my:pyvenv-activate-hook
    (:hook-into python-mode-hook))
  )

(setup elisp-mode
  (defun my:emacs-lisp-hooks ()
    (when (featurep 'cape)
      (setq-local completion-at-point-functions
                  (list (cape-capf-case-fold
                         (cape-capf-super
                          #'tempel-complete
                          #'elisp-completion-at-point))))
      ))
  (:with-hook emacs-lisp-mode-hook
    (:hook my:emacs-lisp-hooks)
    ))

(setup eldoc
  ;; idle時にdelayをかけない
  (:when-loaded
    (setopt eldoc-idle-delay 0)
    ;; echo areaに複数行表示を有効にする
    (setopt eldoc-echo-area-use-multiline-p t))
  
  (:hook-into emacs-lisp-mode-hook
              lisp-interaction-mode-hook
              ielm-mode-hook))

(eval-and-compile
  (defun my:opam-share-directory-p ()
    (let ((opam-share (ignore-errors (car (process-lines "opam" "config" "var" "share")))))
      (and opam-share (file-directory-p opam-share))))

  (defun my:opam-load-path ()
    (let ((opam-share (ignore-errors (car (process-lines "opam" "config" "var" "share")))))
      (when (and opam-share (file-directory-p opam-share))
        (expand-file-name "emacs/site-lisp" opam-share)))))

(when (my:opam-share-directory-p)
  (add-to-list 'load-path (my:opam-load-path)))

(setup ocamlformat
  (:and (my:opam-share-directory-p)
        (:require ocamlformat))
  (setopt ocamlformat-show-errors nil))

(setup tuareg
  (:straight tuareg)

  (:hook my:tuareg-mode-hook-1)
  (:bind
   "C-c C-c" my:dune-compile
   ;; caml-helpを潰しておく
   "C-h" delete-backward-char)
  
  (defun my:tuareg-mode-hook-1 ()
    (let ((bufname (buffer-name)))

      (electric-indent-mode 1)

      (eglot-ensure)))

  (defun my:dune-compile ()
    (interactive)
    (save-buffer)
    (let* ((default-directory
            (or (locate-dominating-file buffer-file-name "Makefile") default-directory))
           (compile-command (concat "(cd " default-directory " && dune build @check)"))
           (compilation-directory
            (or (locate-dominating-file buffer-file-name "Makefile") nil)))
      (recompile)))

  (:when-loaded
    ;; Global tuareg setting
    ;; ただしインデント系統はocamlformatでフォーマットされるので、ほぼここにある設定は意味がなくなっている
    (setopt tuareg-let-always-indent t)
    (setopt tuareg-function-indent 0)
    (setopt tuareg-match-indent 0)
    (setopt tuareg-sig-struct-indent 0)
    (setopt tuareg-match-patterns-aligned t)

    ;; use ocamllsp valid in eglot
    ;; https://github.com/joaotavora/eglot/issues/525
    (put 'tuareg-mode 'eglot-language-id "ocaml")
    )
  )

(setup ocaml-ts-mode
  (:only-if (and (version<= "29" emacs-version) (featurep 'treesit)))
  (:straight (ocaml-ts-mode :type git :host github :repo "dmitrig/ocaml-ts-mode"))
  (:file-match "\\.ml[ily]?\\'" "\\.topml\\'")
  (:hook my:ocaml-ts-mode-hook-1)
  (:bind
   (kbd "C-h") delete-backward-char)
  
  (defun my:ocaml-ts-mode-hook-1 ()
    (let ((bufname (buffer-name)))

      (electric-indent-mode 1)

      (eglot-ensure)))

  (:when-loaded
    ;; use ocamllsp valid in eglot
    ;; https://github.com/joaotavora/eglot/issues/525
    (put 'ocaml-ts-mode 'eglot-language-id "ocaml")
    )
  )

(setup adoc-mode
  (:straight adoc-mode))

(setup lua-mode
  (:straight lua-mode))

(setup markdown-mode
  (:straight markdown-mode))

(setup rst
  (:file-match "\\.rst\\'"))

(setup css-mode
  (:when-loaded
    (setopt css-indent-offset 2)
    )
  
  (defun my:css-setup ()
    (add-node-modules-path)

    (rainbow-mode +1))
  (:with-mode css-ts-mode
    (:file-match "\\.s?css\\'")
    (:hook my:css-setup)
    ))

(setup rainbow-mode
  (:straight rainbow-mode))

(setup yaml-ts-mode
  (:file-match "\\.ya?ml\\'"))

(setup web-mode
  (:straight web-mode)
  (:file-match "\\.html\\'" "\\.rt\\'")

  (:when-loaded
   (setopt web-mode-markup-indent-offset 2)
   (setopt web-mode-code-indent-offset 2))

  (:hook my:web-mode-hook-angular-service)
  
  (defun my:web-mode-hook-angular-service ()
    (when (and
           (string-match-p "\.component\.html\\'" (or buffer-file-name "")))
      (eglot-ensure)))
  )

(setup add-node-modules-path
  (:straight add-node-modules-path))

(setup js-mode
  (:when-loaded
    (setopt js-indent-level 2))
  
  (defun my:js-mode-hook ()
    )

  (:hook my:js-mode-hook)
  (:file-match "\\.[cm]?js\\'"))

(setup typescript-ts-mode
  (:file-match "\\.m?ts\\'" "\\.m?tsx\\'")
  (:with-hook typescript-ts-mode-local-vars-hook
    (:hook my:typescript-ts-mode-hook))
  (:bind
   (kbd "M-j") c-indent-new-comment-line)

  (:when-loaded
    (setopt typescript-ts-mode-indent-offset 2))
  
  (defun my:typescript-ts-mode-hook ()
    (add-node-modules-path)
    (eglot-ensure)))

(setup terraform-mode
  (:straight terraform-mode))

(setup plantuml-mode
  (:straight plantuml-mode)

  (:when-loaded
    (setq plantuml-output-type "png")
    (setopt plantuml-jar-args '("-charset UTF-8"))
    (setopt plantuml-default-exec-mode 'jar)

    (let ((plantuml-jar-file (expand-file-name (locate-user-emacs-file "plantuml.jar"))))
      (setopt plantuml-jar-path plantuml-jar-file)
      (unless (file-exists-p plantuml-jar-file)
        (call-process "curl" nil nil t "-L" "-o" plantuml-jar-file
                      "https://sourceforge.net/projects/plantuml/files/plantuml.jar/download")))
    )
  )

;; protobuf-modeが要求しているのでここで追加している
(setup gtags-mode
  (:straight gtags-mode))

(setup protobuf-mode
  (:straight (protobuf-mode :type git :host github :repo "protocolbuffers/protobuf"))
  (:when-loaded
    (:hook my:protobuf-mode-hook)
    )
  
  (defconst my:protobuf-style
    '((c-basic-offset . 2)
      (indent-tabs-mode . nil)))
  
  (defun my:protobuf-mode-hook ()
    (c-add-style "my-protobuf-style" my:protobuf-style)))

(setup fish-mode
  (:straight fish-mode))

(setup nushell-mode
  (:straight (nushell-mode :type git :host github :repo "mrkkrp/nushell-mode")))

(setup csv-mode
  (:straight csv-mode))

(setup kotlin-mode
  (:straight kotlin-mode)
  (:hook eglot-ensure))

(setup text-mode
  (:when-loaded
    ;; emacs 30.1以降で追加されるオプションで、これがあるとcompleption-at-point-functionsが上書きされてしまうので、
    ;; 一旦切る。これはorg modeとかでも影響する。
    (setopt text-mode-ispell-word-completion nil)))

(setup cc-mode
  (:with-mode c++-mode
    ;; .hはc++-modeで開く
    (:file-match "\\.h\\'")
    )
  
  (defun my:c-mode-hook ()
    (setq completion-mode t)
    ;; compile-windowの設定
    (setq compilation-buffer-name "*compilation*")
    (setq compilation-scroll-output t)
    (setq compilation-read-command t)
    (setq compilation-ask-about-save nil)
    (setq compilation-window-height 10)
    (setq compile-command "make")
    ;; cc-mode内で定義されるキーバインド
    (define-key c-mode-base-map (kbd "C-c C-c")   'comment-region)
    (define-key c-mode-base-map (kbd "C-c C") 'my-c++-cast)
    (define-key c-mode-base-map (kbd "C-c C-M-c") 'uncomment-region)
    (define-key c-mode-base-map (kbd "C-c e")      'c-macro-expand)
    (define-key c-mode-base-map (kbd "C-c c")      'my-compile)
    (define-key c-mode-base-map (kbd "C-c M-c")   'compilation-close)
    (define-key c-mode-base-map (kbd "C-c g")      'gdb)
    (define-key c-mode-base-map (kbd "C-c t")      'toggle-source)
    (define-key c-mode-base-map (kbd "C-c C-d") 'c-down-conditional)
    ;; cc-modeに入る時に自動的にgtags-modeにする
    (gtags-mode t))

  (:with-hook c-mode-common-hook
    (:hook my:c-mode-hook)))

(setup ace-window
  (:straight ace-window)

  (:with-feature posframe
    (add-hook 'emacs-startup-hook #'ace-window-posframe-mode)))

(setup tempel
  (:straight (tempel :type git :host github :repo "minad/tempel" :branch "main"))
  ;; tempel-completeがautoload ではないので、明示的にautoload にする
  (:with-function tempel-complete
    (:autoload-this))
  
  (:with-map tempel-map
    (:bind
     "C-." tempel-next
     "C-," tempel-previous
     )))

(setup symbol-overlay
  (:straight symbol-overlay)
  (:hook-into prog-mode-hook)
  (:when-loaded
    (set-face-attribute 'symbol-overlay-default-face nil :inherit 'highlight :underline t)))

(setup pulsar
  (:straight pulsar)
  (:with-function pulsar-global-mode
    (:hook-into emacs-startup-hook))

  (:when-loaded
    (setopt pulsar-face 'pulsar-magenta)
    ))

(setup imenu-list
  (:straight imenu-list)
  (:when-loaded
    (setopt imenu-list-size 0.25)
    (setopt imenu-list-auto-resize nil)
    (setopt imenu-list-focus-after-activation t)))

(setup which-key
  (:straight which-key)
  (:hook-into emacs-startup-hook)
  (:when-loaded
    (setopt which-key-max-description-length 40)
    (setopt which-key-use-C-h-commands t)))

(setup puni
  (:straight puni)
  (:with-function puni-global-mode
    (:hook-into after-init-hook))
  ;; org-mode/dired-mode/vterm-mode ではあまり意味がないので無効化する
  (:with-function puni-disable-puni-mode
    (:hook-into org-mode-hook
                vterm-mode-hook
                dired-mode-hook)))

(setup diff-hl
  (:straight diff-hl)
  (:hook-into prog-mode-hook
              text-mode-hook)
  (:with-function diff-hl-flydiff-mode
    (:hook-into prog-mode-hook
                text-mode-hook))
  (:with-feature magit
    (:with-hook magit-pre-refresh-hook
      (:hook diff-hl-magit-pre-refresh))
    (:with-hook magit-post-refresh-hook
      (:hook diff-hl-magit-post-refresh)))

  (:when-loaded
    ;; fringeに対してborderを表示しない
    (setopt diff-hl-draw-borders nil)
    ;; 非同期で更新する
    (setopt diff-hl-update-async t)))

(setup flymake
  (:global
   "<f2>"  flymake-goto-next-error
   "S-<f2>"  flymake-goto-prev-error
   ))

(setup posframe
  (:only-if (and window-system my:use-posframe))
  (:straight posframe)

  (when (eq (window-system) 'x)
    (setq x-gtk-resize-child-frames 'resize-mode))

  (setup mozc-posframe
    (:only-if (and my:use-mozc-el my:mozc-helper-locate))
    (:straight (mozc-posframe :type git :host github :repo "derui/mozc-posframe")))
  )

(setup eldoc-box
  (:straight eldoc-box)
  (:with-feature eldoc
    (:hook eldoc-box-hover-mode))
  (:when-loaded
    ;; 複数行の場合だけ表示するようにする
    (setopt eldoc-box-only-multi-line t)))

(setup vundo
  (:straight vundo))

(setup eglot
  (:bind
   "C-c r" eglot-rename
   "C-<return>" eglot-code-actions
   "M-m" eldoc-box-help-at-point
   )
  (:with-hook eldoc-managed-mode-hook
    (:hook eldoc-box-hover-mode
           eglot-booster-mode))

  (:when-loaded
    ;; 補完候補を表示するときとかにあまりにでかすぎてスローダウンしているので0にしておく
    (setopt eglot-events-buffer-config '(:size 0 :format full))
    
    (add-to-list 'eglot-server-programs '(((ocaml-ts-mode :language-id)) . ("ocamllsp")))

    ;; eglotでもhotfuzzを利用するようにする
    (add-to-list 'completion-category-overrides
                 '(eglot (styles hotfuzz basic)))
    )
  )

(setup eglot-booster
  (:straight (eglot-booster :type git :host github :repo "jdtsmith/eglot-booster")))

(setup aggressive-indent
  (:straight aggressive-indent)
  (:hook-into lisp-mode-hook
              emacs-lisp-mode-hook)
  )

(setup copilot
  (:straight (copilot :type git :host github :repo "copilot-emacs/copilot.el" :files ("dist" "*.el")))
  (:bind
   ;; TABにはすでにcompletion-at-pointが入っている状態なので、一旦別に割り当てておく
   "<tab>" my:indent-for-tab-command-dwim
   "TAB" my:indent-for-tab-command-dwim)
  
  (defun my:not-completion-in-region-mode-p ()
    "Predicate to check if `completion-in-region-mode' is enabled."
    (null completion-in-region-mode))

  (defun my:modalka-mode-p ()
    "modal editingが起動していないかどうかを返す"
    (and (boundp modalka-mode)
         (not modalka-mode)))

  (:when-loaded
    ;; 常時やってもあまり意味がないので、タイピングが続いている間はやらないようにする
    (setopt copilot-idle-delay 0.5)
    ;; ファイルを開く度にワーニングになるのだが、実害が基本的にないので、ワーニング自体を無視しておく
    (setopt copilot-indent-offset-warning-disable t)

    ;; evilを使っていないので、evil関連のものは抜いておき、そのかわりにmeowのものを入れておく
    (setq copilot-enable-predicates
          (progn
            (let ((data (seq-filter (lambda (x) (eq x 'evil-insert-state-p))
                                    copilot-enable-predicates)))
              ;; corfuなりが起動している場合は、そもそも有効にしないようにする
              (add-to-list 'data #'my:not-completion-in-region-mode-p)
              (add-to-list 'data #'my:modalka-mode-p)
              data
              )))

    ;; tuaregはocamlにしてもらわないと困る
    (add-to-list 'copilot-major-mode-alist '("tuareg" . "ocaml")))
  
  (defun my:indent-for-tab-command-dwim ()
    "必要があればindent-for-tab-commandを呼び出す"
    (interactive)
    (or (copilot-accept-completion)
        (indent-for-tab-command)))
  )

(setup goggles
  (:straight goggles)
  (:hook-into prog-mode-hook
              text-mode-hook
              )
  (setq-default goggles-pulse t))

(setup selected
  (:straight selected)
  (setq selected-minor-mode-override t)
  
  (:with-map selected-keymap
    (:bind
     "q"  selected-off
     "u"  upcase-region
     "y"  kill-ring-save
     "d"  (lambda () (interactive) (puni-kill-active-region) (modalka-mode +1))
     "c"  (lambda () (interactive) (delete-active-region) (modalka-mode -1))
     "m"  apply-macro-to-region-lines
     "v"  (lambda () (interactive) (deactivate-mark) (setq mark-ring nil))
     )
    )
  )

(setup jinx
  ;; macOSの場合、segfaultが発生してしまうので、一旦止めておく
  (:only-if (not (eq system-type 'darwin)))
  (:straight (jinx :type git :host github :repo "minad/jinx" :branch "main"))
  (:hook-into with-editor-mode-hook)
  (:when-loaded
    (setopt jinx-languages "en_US ja_JP"))
  )

(setup diminish
  (:straight diminish))

(setup nerd-icons
  (:straight (nerd-icons :type git :host github :repo "rainstormstudio/nerd-icons.el"))
  (:require nerd-icons)
  )

(setup nerd-icons-completion
  (:straight nerd-icons-completion)
  
  (:with-feature marginalia
    (:when-loaded
      (:hook nerd-icons-completion-mode)
      )
    )
  )

(setup nerd-icons-dired
  (:straight nerd-icons-dired)
  (:hook-into dired-mode-hook))

(setup nerd-icons-corfu
  (:straight nerd-icons-corfu)
  (:with-feature corfu
    (:when-loaded
      (setopt corfu-margin-formatters '(nerd-icons-corfu-formatter))
      )))

(setup emojify
  (:straight emojify)
  (:with-function global-emojify-mode
    (:hook-into emacs-startup-hook))
  (:when-loaded
    (setopt emojify-display-style 'unicode)
    (setopt emojify-emoji-style '(unicode github))))

(setup notifications
  (:require notifications))

(setup s
  (:straight s)
  (:with-function s-join
    (:autoload-this))
  )

(setup exec-path-from-shell
  (:straight exec-path-from-shell)
  
  (exec-path-from-shell-initialize)
  
  (let ((envs '("GOROOT" "GOPATH" "PATH")))
    (exec-path-from-shell-copy-envs envs)))

(setup rg
  (:straight rg)
  (:with-feature transient
    (:when-loaded 
      (rg-enable-menu))))

(setup langtool
  (:straight langtool)
  (:when-loaded
    (setopt langtool-language-tool-jar my:langtool-cli-path)
    (setopt langtool-default-language "en-US")
    (setopt langtool-java-user-arguments '("-Dfile.encoding=UTF-8"))))

(setup *langtool
  (:and (eq window-system 'x)
        (unless (file-exists-p my:langtool-cli-path)
          (make-directory (expand-file-name "~/.emacs.d/share") t)
          (let ((langtool-url (format "https://languagetool.org/download/LanguageTool-%s.zip" my:langtool-version))
                (output "/tmp/LanguageTool.zip"))

            (call-process "curl" nil nil t "-L" "-o" output langtool-url)
            (call-process "unzip" nil nil t "-d" (expand-file-name "~/.emacs.d/share") output)
            (rename-file (format "~/.emacs.d/share/LanguageTool-%s/languagetool-commandline.jar" my:langtool-version)
                         my:langtool-cli-path t)))
        )
  )

(setup mozc
  (:only-if (and my:use-mozc-el my:mozc-helper-locate))
  (:straight mozc)
  (:when-loaded
    (setq mozc-keymap-kana mozc-keymap-kana-101us)
    (setopt mozc-candidate-style 'posframe)
    (setq mozc-helper-program-name my:mozc-helper-locate)))

(setup projectile
  (:straight projectile)
  (:with-map projectile-command-map
    (:bind
     "s" my:projectile-search-dwim))

  (:when-loaded
    (setopt projectile-enable-idle-timer nil)
    (setopt projectile-enable-caching t)
    (setopt projectile-completion-system 'auto))
  
  (defun my:projectile-search-dwim (search-term)
    "Merge version to search document via grep/ag/rg.
      Use fast alternative if it exists, fallback grep if no alternatives in system.
      "
    (interactive (list (projectile--read-search-string-with-default
                        "Dwim search for")))
    (cond
     ((executable-find "rg") (projectile-ripgrep search-term))
     ((executable-find "ag") (projectile-ag search-term))
     (t (projectile-grep search-term)))))

(setup treesit
  (:and (version<= "29.0.0" emacs-version))
  
  ;; font lockで最大のレベルを利用しておく
  (setopt treesit-font-lock-level 4))

(setup treesit-auto
  (:straight treesit-auto)
  (:with-function treesit-auto-mode
    (:autoload-this)
    (:hook-into prog-mode-hook))
  (:when-loaded
    ;; 対象のパーサがすでにあったら自動的にインストールしてくれる
    (setopt treesit-auto-install t)))

(setup diredfl
  (:straight diredfl)
  (:hook-into dired-mode-hook))

(setup alert
  (:straight alert)

  (:when-loaded
    (setq alert-default-style (cond
                               ((string-match ".*darwin.*" (or system-configuration "")) 'osx-notifier)
                               ((string-match ".*linux-gnu.*" (or system-configuration "")) 'notifications)
                               (t 'message)))
    )
  )

(setup simple-pomodoro
  (:only-if nil)
  (:straight (simple-pomodoro :type git :host github :repo "derui/simple-pomodoro" :files (:defaults "misc/*")))
  
  (setopt simple-pomodoro-auto-short-break t)
  
  (setup simple-pomodoro-notification
    (:require simple-pomodoro-notification)
    (setopt simple-pomodoro-notification-icon `((default . ,(expand-file-name "images/001-tomato.png" user-emacs-directory))))
    (setopt simple-pomodoro-notification-function #'simple-pomodoro-notification))

  (setup simple-pomodoro-mode-line
    (:require simple-pomodoro-mode-line)
    
    (setopt simple-pomodoro-tick-function (lambda (&rest args)
                                            (simple-pomodoro-mode-line-update-text)
                                            (force-mode-line-update)))))

(setup rainbow-delimiters
  (:straight rainbow-delimiters)
  (:hook-into prog-mode-hook))

(setup spacious-padding
  (:straight spacious-padding)
  (:hook-into emacs-startup-hook)
  (:when-loaded
    (setopt spacious-padding-widths '(
                                      :internal-border-width 15
                                      :header-line-width 4
                                      ;; 設定しているmode lineとの相性が悪いので、0にしている
                                      :mode-line-width 0
                                      :tab-width 4
                                      :right-divider-width 30
                                      :left-fringe-width 8
                                      :right-fringe-width 8
                                      :scroll-bar-width 8))
    )
  )

(setup perfect-margin
  (:straight perfect-margin)
  (:when-loaded
    (setopt perfect-margin-disable-in-splittable-check nil)
    ;; mode-lineが右に間伸びするのを防ぐ
    (setopt mode-line-right-align-edge 'right-fringe)
    (setopt perfect-margin-ignore-filters '(window-minibuffer-p)))
  (:hook-into emacs-startup-hook))

(setup breadcrumb
  (:straight breadcrumb)
  (:with-mode breadcrumb-local-mode
    (:hook-into prog-mode-hook)
    )
  )

(setup chokan
  (:straight (chokan :type git :host github :repo "derui/chokan"))
  
  (setup chokan-websocket
    (:with-feature chokan
      (:when-loaded
        (chokan-websocket-setup)))))

(setup anzu
  (:straight anzu)
  (:when-loaded
    ;; mode lineは自分で制御したいので、勝手にCons するのは許容しない
    (setopt anzu-cons-mode-line-p nil)
    )
  (:with-function global-anzu-mode
    (:hook-into emacs-startup-hook)))

(setup indent-bars
  (:straight (indent-bars :type git :host github :repo "jdtsmith/indent-bars" :branch "main"))

  (defun my:indent-bars-mode-dwim ()
    "treesitが有効な場合は `indent-bars-ts-mode' を起動する。treesitが
有効ではないmode の場合は `indent-bars-mode' を代りに起動する"
    (if (and (functionp 'treesit-available-p)
             (treesit-available-p))
        (or (indent-bars-ts-mode +1)
            (indent-bars-mode +1))
      (indent-bars-mode +1)))

  (:with-function my:indent-bars-mode-dwim
    (:hook-into yaml-ts-mode-hook
                rust-ts-mode-hook
                typescript-ts-mode-hook
                ))
  (:when-loaded
    (setopt indent-bars-color '(highlight :face-bg t :blend 0.2))
    (setopt indent-bars-pattern " . .")
    (setopt indent-bars-width-frac 0.15)
    
    ;; treesitをサポートする
    (setopt indent-bars-treesit-support t)

    ;; treesitterにおいて、moduleという単位ではbar を表示しない
    (setopt indent-bars-treesit-ignore-blank-lines-types '("module"))
    )
  )

(setup ultiple-cursors
  (:straight (multiple-cursors :type git :host github :repo "magnars/multiple-cursors.el" :branch "master"))
  (:when-loaded
    (setq mc/cmds-to-run-for-all '(my:treesit-expand-region
                                   puni-kill-active-region))
    ))

(setup vterm
  (:straight (vterm :type git :host github :repo "akermu/emacs-libvterm" :branch "master"))
  (:bind
   (kbd "C-o") window-toggle-side-windows)
  )

(setup migemo
  (:and (and my:migemo-command (executable-find my:migemo-command))
        (progn
          (:straight migemo)
          (:require migemo)))
  (:with-function migemo-init
    (:autoload-this)
    (:hook-into emacs-startup-hook))

  (:when-loaded
    (setopt migemo-command my:migemo-command)
    (setopt migemo-options '("-q" "--emacs"))
    (setopt migemo-dictionary my:migemo-dictionary)
    (setopt migemo-user-dictionary nil)
    (setopt migemo-regex-dictionary nil)
    (setopt migemo-coding-system 'utf-8-unix)
    ;; 遅いのを防ぐためにキャッシュする。
    (setopt migemo-use-pattern-alist t)
    (setopt migemo-use-frequent-pattern-alist t)
    (setopt migemo-pattern-alist-length 1024)
    )
  )

(setup *input-method
  (:global
   (kbd "<Hangul>") my:enable-japanese-input
   (kbd "<henkan>") my:enable-japanese-input
   (kbd "<f13>") my:enable-japanese-input
   (kbd "<Hangul_Hanja>") my:disable-japanese-input
   (kbd "<muhenkan>") my:disable-japanese-input
   (kbd "C-<f13>") my:disable-japanese-input
   )
  
  (defun my:enable-japanese-input ()
    (interactive)
    (set-input-method my:input-method))

  (defun my:disable-japanese-input ()
    (interactive)
    (set-input-method nil))

  (setq default-input-method my:input-method))

(setup dashboard
  (:straight dashboard)
  (diminish 'dashboard-mode)
  (:require dashboard)

  (dashboard-modify-heading-icons '((recents . "nf-oct-file")
                                    (projects . "nf-oct-project")
                                    (agenda . "nf-oct-calendar")))
  (setopt dashboard-display-icons-p t)
  (setopt dashboard-set-heading-icons t)
  (setopt dashboard-set-file-icons t)
  (setopt dashboard-icon-type 'nerd-icons)
  (setopt dashboard-vertically-center-content t)

  (setopt dashboard-startup-banner 'ascii)
  (setopt dashboard-set-navigator t)
  (setopt dashboard-set-init-info t)
  (setopt dashboard-items '((recents . 15)
                            (projects . 5)
                            (agenda . 5)))
  (setopt dashboard-banner-ascii "
  ____
 |  _ \\  ___ _ __ _   _  ___ _ __ ___   __ _  ___ ___
 | | | |/ _ \\ '__| | | |/ _ \\ '_ ` _ \\ / _` |/ __/ __|
 | |_| |  __/ |  | |_| |  __/ | | | | | (_| | (__\\__ \\
 |____/ \\___|_|   \\__,_|\\___|_| |_| |_|\\__,_|\\___|___/
"))

(setq file-name-handler-alist my-saved-file-name-handler-alist)

(setq gc-cons-threshold #x10000000)
(setq gc-cons-percentage 0.5)
(setq garbage-collection-messages t)
;; font cacheのcompact化を抑制する
(setq inhibit-compacting-font-caches t)
